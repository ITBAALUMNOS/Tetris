*** EVALUATION ***
ANSI-C/cC++ Compiler for HC12 V-5.0.41 Build 10203, Jul 23 2010

    1:  #include <stdio.h>
    2:  #include <stdlib.h>
    3:  #include "LEDdisplay.h"
    4:  #include "buttons_and_timers.h"
    5:  #include "mc9s12xdp512.h"
    6:  #include "display_spi_management.h"
    7:  #define GAME_END_ANI_SPEED	75	//MS
    8:  #define DROP_XCORD	((DISPLAY_WIDTH - PIECE_CONTAINER_SIZE)/2)
    9:  #define DROP_YCORD	1
   10:  #define NUM_BLINK_CLR_LINE 3
   11:  
   12:  //Pieces enum
   13:  #define PIECE_CONTAINER_SIZE    4
   14:  #define TOTAL_PIECES 7  //Pieces from 1 to 7
   15:  typedef enum   pieces { NO_PIECE = 0, PIECE_I, PIECE_J, PIECE_L, PIECE_O, PIECE_S, PIECE_T, PIECE_Z }  piece_type_t;   //Will take as int remember to CAST!!!!!!
   16:  #define TOTAL_ORIENTATIONS 4
   17:  typedef enum { RIGHT = 0, STRAIGHT, LEFT, UPSIDE_DOWN } rotation_t;     //Idem
   18:  
   19:  typedef enum { PRE_START = 0, GAME_START, MAIN_MENU, NORMAL_PLAY, GAME_PAUSED, CLEARING_ROWS, GAME_FINISHED_ANIMATION } game_states_t;
   20:  
   21:  //MUST HAVE SAME VALUES AS ENUM IN BUTTON AND TIMERS
   22:  enum BUTTONS { JOYSTICK_UP = 0, JOYSTICK_DOWN, JOYSTICK_LEFT, JOYSTICK_RIGHT, ROTATE_COUNT, ROTATE_CLOCK, PAUSE, RESET };
   23:  /*
   24:  *  A piece will have the following format it will be contained inside a "4 x 4 array" (represented with a 2 byte/16 bit unsigned int)
   25:  *
   26:  *   Msbit
   27:  *   ^
   28:  *  | _ _ _
   29:  *  |_|_|_|_|
   30:  *  |_|_|_|_|
   31:  *  |_|_|_|_|
   32:  *  |_|_|_|_--> Lsbit
   33:  *
   34:  * Where each bit represents if the square is in use or not
   35:  *	Examples:
   36:  *
   37:  *  I:
   38:  *   _ _ _ _
   39:  *  |_|*|_|_|   0100
   40:  *  |_|*|_|_|	0100	Whole int: 0100 0100 0100 0100 = 0x4444  BIG ENDIAN!!!
   41:  *  |_|*|_|_|	0100
   42:  *  |_|*|_|_|	0100
   43:  *
   44:  *   T:
   45:  *   _ _ _ _
   46:  *  |_|_|_|_|   0000
   47:  *  |_|_|*|_|	0100	Whole int: 0000 0100 0111 0000 = 0x0470  BIG ENDIAN!!!
   48:  *  |_|*|*|*|	0111
   49:  *  |_|_|_|_|	0000
   50:  */
   51:  
   52:  typedef unsigned int piece_shape_t; //16 bits
   53:  static const piece_shape_t tetris_pieces[1 + TOTAL_PIECES][TOTAL_ORIENTATIONS] =
   54:  {
   55:  	//NO_PIECE (Just to keep enum order)
   56:  	{ 0x0000,0x0000,0x0000,0x0000 },
   57:  	// PIECE_I
   58:  	{ 0x0F00,0x2222,0x00F0,0x4444 },
   59:  	// PIECE_J
   60:  	{ 0x8E00,0x6440,0x0E20,0x44C0 },
   61:  	// PIECE_L
   62:  	{ 0x2E00,0x4460,0x0E80,0xC440 },
   63:  	//PIECE_O
   64:  	{ 0x6600,0x6600,0x6600,0x6600 },
   65:  	// PIECE_S
   66:  	{ 0x6C00,0x4620,0x06C0,0x8C40 },
   67:  	// PIECE_T
   68:  	{ 0x4E00,0x4640,0x0E40,0x4C40 },
   69:  	// PIECE_Z
   70:  	{ 0xC600,0x2640,0x0C60,0x4C80 }
   71:  };
   72:  /*
   73:  const color piece_color[1 + TOTAL_PIECES] =
   74:  {
   75:  //{g,r,b}               //SAME ORDER AS piece_type_t enum
   76:  
   77:  { 0,		0,     		0 },  	//NO PIECE
   78:  { 255,		0,      	0 },  	//PIECE_I
   79:  { 0,		255,			0 },	//PIECE_J
   80:  { 0,		0,			255 },	//PIECE_L
   81:  { 255,		255,			255 },	//PIECE_O
   82:  { 255,		0,      	255 },	//PIECE_S
   83:  { 255,		255,			0 },	//PIECE_T
   84:  { 0,		255,		255},	//PIECE_Z
   85:  };
   86:  };*/
   87:  const color piece_color[1 + TOTAL_PIECES] =
   88:  {
   89:  	//{g,r,b}               //SAME ORDER AS piece_type_t enum
   90:  
   91:  	{ 0,		0,     		0 },  	//NO PIECE
   92:  	{ 16,		0,      	8 },  	//PIECE_I
   93:  	{ 0,		0,			16 },	//PIECE_J
   94:  	{ 8,		25,			0 },	//PIECE_L
   95:  	{ 16,		16,			0 },	//PIECE_O
   96:  	{ 16,		8,      	0 },	//PIECE_S
   97:  	{ 0,		8,			8 },	//PIECE_T
   98:  	{ 0,		16,		0 },	//PIECE_Z
   99:  };
  100:  typedef struct
  101:  {
  102:  	unsigned int fall_piece : 1;//If the piece is falling this is set to 1, used to distinguish placed pieces from the active one
  103:  	unsigned int redraw : 1;//Modified blocks will be set to 1, allowing for optimization when having to draw.
  104:  
  105:  	unsigned int : 1;//Empty 
  106:  	unsigned int : 1;//Empty
  107:  	unsigned int : 1;//Empty open for future use
  108:  	unsigned int piece_type : 3;//used to distinguish between piece type 
  109:  }block_t;
  110:  #define HIDDEN_ROWS 4
  111:  
  112:  #define SCORE_LEVEL_UP	200
  113:  #define NUMBER_SPEEDS	16
  114:  static unsigned int game_speed[NUMBER_SPEEDS] =
  115:  {
  116:  	200, 190, 180, 170, 160, 150, 140, 130, 120 , 110 , 100 , 90 , 80 , 70 , 60 , 50
  117:  };
  118:  
  119:  static unsigned int score_per_line_cleared[] =
  120:  {
  121:  	0, 40, 100 , 200 , 400
  122:  };
  123:  
  124:  static block_t logic_board_data[HIDDEN_ROWS + DISPLAY_HEIGHT][DISPLAY_WIDTH];
  125:  //Pointers to rows! In order to implement fast row erase
  126:  
  127:  
  128:  
  129:  block_t(*board[HIDDEN_ROWS + DISPLAY_HEIGHT])[DISPLAY_WIDTH];
  130:  
  131:  void init_row_pointers()
  132:  {
*** EVALUATION ***

Function: init_row_pointers
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  133:  	int j;
  134:  	for (j = 0; j < DISPLAY_HEIGHT + HIDDEN_ROWS; j++)
  0000 c7           [1]     CLRB  
  0001 87           [1]     CLRA  
  135:  		board[j] = &(logic_board_data[j]);
  0002 b745         [1]     TFR   D,X
  0004 1848         [2]     LSLX  
  0006 b746         [1]     TFR   D,Y
  0008 59           [1]     LSLD  
  0009 59           [1]     LSLD  
  000a 59           [1]     LSLD  
  000b c30000       [2]     ADDD  #logic_board_data
  000e 6ce20000     [3]     STD   board,X
  0012 02           [1]     INY   
  0013 8d0024       [2]     CPY   #36
  0016 b764         [1]     TFR   Y,D
  0018 2de8         [3/1]   BLT   *-22 ;abs = 0002
  136:  }
  001a 3d           [5]     RTS   
  137:  
  138:  
  139:  void seed_rand(void);    //Call this after initializing everything!
  140:  void clear_board_to_block(block_t block_to_clear);
  141:  void update_display_data(void);
  142:  void update_all_display_data(void);
  143:  unsigned char get_piece_data(signed int piece_x, unsigned int piece_y, piece_type_t piece_type, rotation_t rotation);
  144:  unsigned char can_place_piece(signed int x, unsigned int y, piece_type_t piece_type, rotation_t rotation);
  145:  void remove_piece(signed int x, unsigned int y, piece_type_t piece_type, rotation_t rotation);
  146:  void place_falling_piece(signed int x, unsigned int y, piece_type_t piece_type, rotation_t rotation);
  147:  void place_static_piece(signed int x, unsigned int y, piece_type_t piece_type, rotation_t rotation);
  148:  
  149:  unsigned char move_piece_up(signed char x, signed char y, piece_type_t piece_type, rotation_t rotation);
  150:  unsigned char move_piece_down(signed char x, signed char y, piece_type_t piece_type, rotation_t rotation);
  151:  unsigned char move_piece_left(signed char x, signed char y, piece_type_t piece_type, rotation_t rotation);
  152:  unsigned char move_piece_right(signed char x, signed char y, piece_type_t piece_type, rotation_t rotation);
  153:  unsigned char rotate_piece_clockwise(signed char * x, signed char * y, piece_type_t *piece_type, rotation_t * rotation);
  154:  unsigned char rotate_piece_counterclockwise(signed char * x, signed char * y, piece_type_t *piece_type, rotation_t * rotation);
  155:  unsigned char check_cleared_rows(unsigned char y_cord);
  156:  void move_line_to_top(unsigned char line_row);
  157:  unsigned char is_game_over(void);
  158:  
  159:  void manage_button_down(signed char * x, signed char * y, piece_type_t * piece, rotation_t * rotation, EVENT_T * ev, unsigned char *drop_piece_f, game_states_t * current_state);
  160:  unsigned char game_end_animation(signed char * y, piece_type_t last_piece_placed);
  161:  unsigned char clearing_row_animation(signed char y, unsigned char cleared_rows, unsigned long int * score);
  162:  void game_pause_animation(signed char x, unsigned char y, piece_type_t piece_type, rotation_t rotation);
  163:  
  164:  void clear_line(unsigned char y_cord);
  165:  void move_line_up(unsigned char y_cord);
  166:  void place_piece_line(unsigned char y_cord, piece_type_t piece);
  167:  void set_row_redraw(unsigned char y_cord);
  168:  
  169:  void draw_letter_t(piece_type_t piece, signed char y, signed char x);
  170:  void draw_letter_e(piece_type_t piece, signed char y, signed char x);
  171:  void draw_letter_r(piece_type_t piece, signed char y, signed char x);
  172:  void draw_letter_i(piece_type_t piece, signed char y, signed char x);
  173:  void draw_letter_s(piece_type_t piece, signed char y, signed char x);
  174:  //Note for allegro simulator:     
  175:  //BUTTONS 0 to 7 are mapped from Q to I. You can change this in buttons_and_timers.c variable button_map!
  176:  int main(void)
  177:  {
*** EVALUATION ***

Function: main
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 1bf1e8       [2]     LEAS  -24,SP
  178:  	//REMEMBER VARIABLES BEFORE CODE!
  179:  	//Connect buttons to PORTB with pull-up resistors
  180:  	unsigned char redraw = 0, cleared_rows, drop_piece_f = 0;
  0003 69f015       [3]     CLR   21,SP
  181:  	unsigned int piece_fall_time = 50; //ms para que empiece rapido la animacion
  0006 c632         [1]     LDAB  #50
  0008 87           [1]     CLRA  
  0009 6cf013       [3]     STD   19,SP
  182:  	unsigned long int score = 0;  
  000c 69f012       [3]     CLR   18,SP
  000f 69f011       [3]     CLR   17,SP
  0012 69f010       [3]     CLR   16,SP
  0015 698f         [2]     CLR   15,SP
  183:  	signed char x, y;
  184:  	piece_type_t piece;
  185:  	rotation_t rotation;
  186:  	game_states_t current_state = PRE_START;
  0017 698e         [2]     CLR   14,SP
  0019 698d         [2]     CLR   13,SP
  187:  	block_t empty;
  188:  	//DO NOT FORGET THIS FUNCTION
  189:  	init_row_pointers();
  001b 0700         [4]     BSR   init_row_pointers
  190:  
  191:  	configure_spi_max7219_display();
  001d 160000       [4]     JSR   configure_spi_max7219_display
  192:  	empty.fall_piece = 0;
  193:  	empty.redraw = 1;
  0020 0c8402       [4]     BSET  4,SP,#2
  194:  	empty.piece_type = NO_PIECE;
  0023 0d84e1       [4]     BCLR  4,SP,#225
  195:  	LEDdisplay_init();
  0026 160000       [4]     JSR   LEDdisplay_init
  196:  	buttons_and_timers_init();
  0029 160000       [4]     JSR   buttons_and_timers_init
  197:  	set_timer_period_ms(TIMER_0, piece_fall_time);
  002c c7           [1]     CLRB  
  002d 37           [2]     PSHB  
  002e c632         [1]     LDAB  #50
  0030 87           [1]     CLRA  
  0031 160000       [4]     JSR   set_timer_period_ms
  0034 1b81         [2]     LEAS  1,SP
  198:  	clear_board_to_block(empty);
  0036 e684         [3]     LDAB  4,SP
  0038 160000       [4]     JSR   clear_board_to_block
  199:  	update_display_data();
  003b 160000       [4]     JSR   update_display_data
  200:  	//This is to indicate that device is working and waiting for input to seed rand
  201:  	LEDdisplay_set_pixel(0, 0, LEDdisplay_map_rgb(255, 255, 255));
  003e c7           [1]     CLRB  
  003f 37           [2]     PSHB  
  0040 37           [2]     PSHB  
  0041 1a87         [2]     LEAX  7,SP
  0043 34           [2]     PSHX  
  0044 53           [1]     DECB  
  0045 37           [2]     PSHB  
  0046 37           [2]     PSHB  
  0047 160000       [4]     JSR   LEDdisplay_map_rgb
  004a 1b84         [2]     LEAS  4,SP
  004c ee88         [3]     LDX   8,SP
  004e e687         [3]     LDAB  7,SP
  0050 160000       [4]     JSR   LEDdisplay_set_pixel
  202:  	LEDdisplay_set_pixel(DISPLAY_WIDTH - 1, 0, LEDdisplay_map_rgb(255, 255, 255));
  0053 c607         [1]     LDAB  #7
  0055 6ba0         [2]     STAB  1,+SP
  0057 c7           [1]     CLRB  
  0058 37           [2]     PSHB  
  0059 1a87         [2]     LEAX  7,SP
  005b 34           [2]     PSHX  
  005c 53           [1]     DECB  
  005d 37           [2]     PSHB  
  005e 37           [2]     PSHB  
  005f 160000       [4]     JSR   LEDdisplay_map_rgb
  0062 1b84         [2]     LEAS  4,SP
  0064 ee88         [3]     LDX   8,SP
  0066 e687         [3]     LDAB  7,SP
  0068 160000       [4]     JSR   LEDdisplay_set_pixel
  203:  	LEDdisplay_set_pixel(0, DISPLAY_HEIGHT - 1, LEDdisplay_map_rgb(255, 255, 255));
  006b c7           [1]     CLRB  
  006c 6ba0         [2]     STAB  1,+SP
  006e 861f         [1]     LDAA  #31
  0070 36           [2]     PSHA  
  0071 1a87         [2]     LEAX  7,SP
  0073 34           [2]     PSHX  
  0074 53           [1]     DECB  
  0075 37           [2]     PSHB  
  0076 37           [2]     PSHB  
  0077 160000       [4]     JSR   LEDdisplay_map_rgb
  007a 1b84         [2]     LEAS  4,SP
  007c ee88         [3]     LDX   8,SP
  007e e687         [3]     LDAB  7,SP
  0080 160000       [4]     JSR   LEDdisplay_set_pixel
  204:  	LEDdisplay_set_pixel(DISPLAY_WIDTH - 1, DISPLAY_HEIGHT - 1, LEDdisplay_map_rgb(255, 255, 255));
  0083 cc1f07       [2]     LDD   #7943
  0086 6ba0         [2]     STAB  1,+SP
  0088 36           [2]     PSHA  
  0089 1a87         [2]     LEAX  7,SP
  008b 34           [2]     PSHX  
  008c c6ff         [1]     LDAB  #255
  008e 37           [2]     PSHB  
  008f 37           [2]     PSHB  
  0090 160000       [4]     JSR   LEDdisplay_map_rgb
  0093 1b84         [2]     LEAS  4,SP
  0095 ee88         [3]     LDX   8,SP
  0097 e687         [3]     LDAB  7,SP
  0099 160000       [4]     JSR   LEDdisplay_set_pixel
  009c 1b82         [2]     LEAS  2,SP
  205:  
  206:  	LEDdisplay_update();
  009e 160000       [4]     JSR   LEDdisplay_update
  207:  	send_number_display(12345678);
  00a1 cc614e       [2]     LDD   #24910
  00a4 ce00bc       [2]     LDX   #188
  00a7 160000       [4]     JSR   send_number_display
  208:  	seed_rand();
  00aa 160000       [4]     JSR   seed_rand
  209:  	clear_board_to_block(empty);
  00ad e684         [3]     LDAB  4,SP
  00af 160000       [4]     JSR   clear_board_to_block
  210:  	update_display_data();
  00b2 160000       [4]     JSR   update_display_data
  211:  	LEDdisplay_update();
  00b5 160000       [4]     JSR   LEDdisplay_update
  212:  	set_button_repeat_period_ms(100);
  00b8 c664         [1]     LDAB  #100
  00ba 87           [1]     CLRA  
  00bb 160000       [4]     JSR   set_button_repeat_period_ms
  213:  	flush_event_queue();
  00be 160000       [4]     JSR   flush_event_queue
  214:  	for (;;)
  00c1 060000       [3]     JMP   main:0x03d1
  215:  	{
  216:  		EVENT_T ev;
  217:  		redraw = 0;
  00c4 69f016       [3]     CLR   22,SP
  218:  		configure_spi_max7219_display();
  00c7 160000       [4]     JSR   configure_spi_max7219_display
  219:  		send_number_display(score);
  00ca ecf011       [3]     LDD   17,SP
  00cd ee8f         [3]     LDX   15,SP
  00cf 160000       [4]     JSR   send_number_display
  220:  		wait_for_event(&ev);
  00d2 1a82         [2]     LEAX  2,SP
  00d4 b754         [1]     TFR   X,D
  00d6 160000       [4]     JSR   wait_for_event
  221:  
  222:  		switch (current_state)
  00d9 ec8d         [3]     LDD   13,SP
  00db 160000       [4]     JSR   _CASE_CHECKED
  00de 0007         DC.W  7
  00e0 0000         DC.W  main:0x03c0
  00e2 0000         DC.W  main:0x00f0
  00e4 0000         DC.W  main:0x0156
  00e6 0000         DC.W  main:0x03c0
  00e8 0000         DC.W  main:0x019f
  00ea 0000         DC.W  main:0x0326
  00ec 0000         DC.W  main:0x0291
  00ee 0000         DC.W  main:0x039b
  223:  		{
  224:  		case PRE_START:
  225:  			score = 0;
  00f0 c7           [1]     CLRB  
  00f1 87           [1]     CLRA  
  00f2 6cf011       [3]     STD   17,SP
  00f5 6c8f         [2]     STD   15,SP
  226:  			send_number_display(score);
  00f7 b745         [1]     TFR   D,X
  00f9 160000       [4]     JSR   send_number_display
  227:  			draw_letter_t(PIECE_I, HIDDEN_ROWS + 1, 1);
  00fc c601         [1]     LDAB  #1
  00fe 87           [1]     CLRA  
  00ff 3b           [2]     PSHD  
  0100 c605         [1]     LDAB  #5
  0102 37           [2]     PSHB  
  0103 c601         [1]     LDAB  #1
  0105 160000       [4]     JSR   draw_letter_t
  228:  			draw_letter_e(PIECE_J, HIDDEN_ROWS + 6, 4);
  0108 c602         [1]     LDAB  #2
  010a 87           [1]     CLRA  
  010b 6ca0         [2]     STD   1,+SP
  010d c60a         [1]     LDAB  #10
  010f 37           [2]     PSHB  
  0110 c604         [1]     LDAB  #4
  0112 160000       [4]     JSR   draw_letter_e
  229:  			draw_letter_t(PIECE_L, HIDDEN_ROWS + 11, 1);
  0115 c603         [1]     LDAB  #3
  0117 87           [1]     CLRA  
  0118 6ca0         [2]     STD   1,+SP
  011a c60f         [1]     LDAB  #15
  011c 37           [2]     PSHB  
  011d c601         [1]     LDAB  #1
  011f 160000       [4]     JSR   draw_letter_t
  230:  			draw_letter_r(PIECE_O, HIDDEN_ROWS + 16, 4);
  0122 c604         [1]     LDAB  #4
  0124 87           [1]     CLRA  
  0125 6ca0         [2]     STD   1,+SP
  0127 c614         [1]     LDAB  #20
  0129 37           [2]     PSHB  
  012a c604         [1]     LDAB  #4
  012c 160000       [4]     JSR   draw_letter_r
  231:  			draw_letter_i(PIECE_S, HIDDEN_ROWS + 21, 1);
  012f c605         [1]     LDAB  #5
  0131 87           [1]     CLRA  
  0132 6ca0         [2]     STD   1,+SP
  0134 c619         [1]     LDAB  #25
  0136 37           [2]     PSHB  
  0137 c601         [1]     LDAB  #1
  0139 160000       [4]     JSR   draw_letter_i
  232:  			draw_letter_s(PIECE_T, HIDDEN_ROWS + 26, 4);
  013c c606         [1]     LDAB  #6
  013e 87           [1]     CLRA  
  013f 6ca0         [2]     STD   1,+SP
  0141 c61e         [1]     LDAB  #30
  0143 37           [2]     PSHB  
  0144 c604         [1]     LDAB  #4
  0146 160000       [4]     JSR   draw_letter_s
  0149 1b83         [2]     LEAS  3,SP
  233:  			if (ev.id == BUTTON_PRESS)
  014b e682         [3]     LDAB  2,SP
  014d 182601f5     [4/3]   LBNE  *+505 ;abs = 0346
  234:  				current_state = GAME_START;
  0151 c601         [1]     LDAB  #1
  0153 060000       [3]     JMP   main:0x02b5
  235:  			redraw = 1;
  236:  			break;
  237:  		case GAME_START:
  238:  
  239:  			flush_event_queue();
  0156 160000       [4]     JSR   flush_event_queue
  240:  			clear_board_to_block(empty);
  0159 e684         [3]     LDAB  4,SP
  015b 160000       [4]     JSR   clear_board_to_block
  241:  			place_falling_piece(x = DROP_XCORD, y = DROP_YCORD, piece = (rand() % TOTAL_PIECES) + 1, rotation = rand() % TOTAL_ORIENTATIONS); //DESPUES CAMBIAR RESTO/MODULO
  015e c602         [1]     LDAB  #2
  0160 6b8a         [2]     STAB  10,SP
  0162 87           [1]     CLRA  
  0163 3b           [2]     PSHD  
  0164 57           [1]     ASRB  
  0165 6b8b         [2]     STAB  11,SP
  0167 3b           [2]     PSHD  
  0168 160000       [4]     JSR   rand
  016b ce0007       [2]     LDX   #7
  016e 1815         [12]    IDIVS 
  0170 c30001       [2]     ADDD  #1
  0173 6c8f         [2]     STD   15,SP
  0175 3b           [2]     PSHD  
  0176 160000       [4]     JSR   rand
  0179 ce0004       [2]     LDX   #4
  017c 1815         [12]    IDIVS 
  017e 6c86         [2]     STD   6,SP
  0180 160000       [4]     JSR   place_falling_piece
  0183 1b86         [2]     LEAS  6,SP
  242:  			update_display_data();
  0185 160000       [4]     JSR   update_display_data
  243:  			LEDdisplay_update();
  0188 160000       [4]     JSR   LEDdisplay_update
  244:  			current_state = NORMAL_PLAY;
  018b c603         [1]     LDAB  #3
  018d 87           [1]     CLRA  
  018e 6c8d         [2]     STD   13,SP
  245:  			set_timer_period_ms(TIMER_0, piece_fall_time = game_speed[0]);//FALL TIME
  0190 36           [2]     PSHA  
  0191 fc0000       [3]     LDD   game_speed
  0194 6cf014       [3]     STD   20,SP
  0197 160000       [4]     JSR   set_timer_period_ms
  019a 1b81         [2]     LEAS  1,SP
  246:  
  247:  			break;
  019c 060000       [3]     JMP   main:0x03c0
  248:  
  249:  		case NORMAL_PLAY:
  250:  			switch (ev.id)
  019f e682         [3]     LDAB  2,SP
  01a1 c103         [1]     CMPB  #3
  01a3 18220219     [4/3]   LBHI  *+541 ;abs = 03c0
  01a7 87           [1]     CLRA  
  01a8 160000       [4]     JSR   _CASE_CHECKED
  01ab 0004         DC.W  4
  01ad 0000         DC.W  main:0x03c0
  01af 0000         DC.W  main:0x01b7
  01b1 0000         DC.W  main:0x01de
  01b3 0000         DC.W  main:0x03c0
  01b5 0000         DC.W  main:0x01fc
  251:  			{
  252:  			case BUTTON_PRESS:   
  253:  				if (!drop_piece_f) // If a piece is hard dropping, (joystick moved up) no other events button events are attended
  01b7 e6f015       [3]     LDAB  21,SP
  01ba 18260202     [4/3]   LBNE  *+518 ;abs = 03c0
  254:  				{
  255:  					manage_button_down(&x, &y, &piece, &rotation, &ev, &drop_piece_f, &current_state);
  01be 1a8a         [2]     LEAX  10,SP
  01c0 34           [2]     PSHX  
  01c1 1a8b         [2]     LEAX  11,SP
  01c3 34           [2]     PSHX  
  01c4 1a8f         [2]     LEAX  15,SP
  01c6 34           [2]     PSHX  
  01c7 1a86         [2]     LEAX  6,SP
  01c9 34           [2]     PSHX  
  01ca 1a8a         [2]     LEAX  10,SP
  01cc 34           [2]     PSHX  
  01cd 1af01f       [2]     LEAX  31,SP
  01d0 34           [2]     PSHX  
  01d1 1af019       [2]     LEAX  25,SP
  01d4 b754         [1]     TFR   X,D
  01d6 160000       [4]     JSR   manage_button_down
  01d9 1b8c         [2]     LEAS  12,SP
  01db 060000       [3]     JMP   main:0x0346
  256:  					redraw = 1;
  257:  				}
  258:  				break;
  259:  
  260:  			case BUTTON_REPEAT: //Instead of detecting button repeat, it's send to priority queue as button press
  261:  				if (ev.data == JOYSTICK_UP || ev.data == JOYSTICK_DOWN || ev.data == JOYSTICK_LEFT || ev.data == JOYSTICK_RIGHT) //Only repeat the movement buttons no the rotating
  01de e683         [3]     LDAB  3,SP
  01e0 270e         [3/1]   BEQ   *+16 ;abs = 01f0
  01e2 c101         [1]     CMPB  #1
  01e4 270a         [3/1]   BEQ   *+12 ;abs = 01f0
  01e6 c102         [1]     CMPB  #2
  01e8 2706         [3/1]   BEQ   *+8 ;abs = 01f0
  01ea c103         [1]     CMPB  #3
  01ec 182601d0     [4/3]   LBNE  *+468 ;abs = 03c0
  262:  				{
  263:  					ev.id = BUTTON_PRESS;
  01f0 6982         [2]     CLR   2,SP
  264:  					register_event_in_priority_queue(&ev);
  01f2 1a82         [2]     LEAX  2,SP
  01f4 b754         [1]     TFR   X,D
  01f6 160000       [4]     JSR   register_event_in_priority_queue
  01f9 060000       [3]     JMP   main:0x03c0
  265:  				}
  266:  				break;
  267:  
  268:  			case TIMER:
  269:  
  270:  				if (move_piece_down(x, y, piece, rotation))
  01fc e68a         [3]     LDAB  10,SP
  01fe 37           [2]     PSHB  
  01ff e68a         [3]     LDAB  10,SP
  0201 37           [2]     PSHB  
  0202 ec8d         [3]     LDD   13,SP
  0204 3b           [2]     PSHD  
  0205 ec84         [3]     LDD   4,SP
  0207 160000       [4]     JSR   move_piece_down
  020a 1b84         [2]     LEAS  4,SP
  020c 044105       [3]     TBEQ  B,*+8 ;abs = 0214
  271:  				{
  272:  					y++;
  020f 6289         [3]     INC   9,SP
  273:  					redraw = 1;
  274:  				}
  0211 060000       [3]     JMP   main:0x0346
  275:  				else
  276:  				{
  277:  					place_static_piece(x, y, piece, rotation);
  0214 e68a         [3]     LDAB  10,SP
  0216 b715         [1]     SEX   B,X
  0218 34           [2]     PSHX  
  0219 e68b         [3]     LDAB  11,SP
  021b b715         [1]     SEX   B,X
  021d 34           [2]     PSHX  
  021e ec8f         [3]     LDD   15,SP
  0220 3b           [2]     PSHD  
  0221 ec86         [3]     LDD   6,SP
  0223 160000       [4]     JSR   place_static_piece
  0226 1b86         [2]     LEAS  6,SP
  278:  					if (drop_piece_f)
  0228 e6f015       [3]     LDAB  21,SP
  022b 2712         [3/1]   BEQ   *+20 ;abs = 023f
  279:  					{
  280:  						drop_piece_f ^= 1; //sets to 0
  022d c801         [1]     EORB  #1
  022f 6bf015       [3]     STAB  21,SP
  281:  						set_timer_period_ms(TIMER_0, piece_fall_time);//FALL TIME
  0232 c7           [1]     CLRB  
  0233 37           [2]     PSHB  
  0234 ecf014       [3]     LDD   20,SP
  0237 160000       [4]     JSR   set_timer_period_ms
  023a 1b81         [2]     LEAS  1,SP
  282:  						flush_event_queue();
  023c 160000       [4]     JSR   flush_event_queue
  283:  					}
  284:  					cleared_rows = check_cleared_rows(y);
  023f e689         [3]     LDAB  9,SP
  0241 160000       [4]     JSR   check_cleared_rows
  0244 6bf017       [3]     STAB  23,SP
  285:  					if (cleared_rows)
  0247 270f         [3/1]   BEQ   *+17 ;abs = 0258
  286:  					{
  287:  						set_timer_period_ms(TIMER_0, 200); //Clear screen time
  0249 c7           [1]     CLRB  
  024a 37           [2]     PSHB  
  024b c6c8         [1]     LDAB  #200
  024d 87           [1]     CLRA  
  024e 160000       [4]     JSR   set_timer_period_ms
  0251 1b81         [2]     LEAS  1,SP
  288:  						current_state = CLEARING_ROWS;//desactivar el redraw
  0253 c605         [1]     LDAB  #5
  289:  					}
  0255 060000       [3]     JMP   main:0x0396
  290:  					else if (y <= 4 && is_game_over()) // no point in checking if y is over 4
  0258 e689         [3]     LDAB  9,SP
  025a c104         [1]     CMPB  #4
  025c 2e09         [3/1]   BGT   *+11 ;abs = 0267
  025e 160000       [4]     JSR   is_game_over
  0261 044103       [3]     TBEQ  B,*+6 ;abs = 0267
  0264 060000       [3]     JMP   main:0x0394
  291:  						current_state = GAME_FINISHED_ANIMATION;
  292:  					else
  293:  					{
  294:  						place_falling_piece(x = DROP_XCORD, y = DROP_YCORD, piece = (rand() % TOTAL_PIECES) + 1, rotation = rand() % TOTAL_ORIENTATIONS);//cambiar por and dsp
  0267 c602         [1]     LDAB  #2
  0269 6b8a         [2]     STAB  10,SP
  026b 87           [1]     CLRA  
  026c 3b           [2]     PSHD  
  026d 57           [1]     ASRB  
  026e 6b8b         [2]     STAB  11,SP
  0270 3b           [2]     PSHD  
  0271 160000       [4]     JSR   rand
  0274 ce0007       [2]     LDX   #7
  0277 1815         [12]    IDIVS 
  0279 c30001       [2]     ADDD  #1
  027c 6c8f         [2]     STD   15,SP
  027e 3b           [2]     PSHD  
  027f 160000       [4]     JSR   rand
  0282 ce0004       [2]     LDX   #4
  0285 1815         [12]    IDIVS 
  0287 6c86         [2]     STD   6,SP
  0289 160000       [4]     JSR   place_falling_piece
  028c 1b86         [2]     LEAS  6,SP
  028e 060000       [3]     JMP   main:0x03bb
  295:  						redraw = 1;
  296:  					}
  297:  
  298:  				}
  299:  				break;
  300:  
  301:  			default:
  302:  				break;
  303:  			}
  304:  			break;
  305:  
  306:  		case CLEARING_ROWS:
  307:  			if (ev.id == TIMER)
  0291 e682         [3]     LDAB  2,SP
  0293 c103         [1]     CMPB  #3
  0295 18260127     [4/3]   LBNE  *+299 ;abs = 03c0
  308:  			{
  309:  				if (clearing_row_animation(y, cleared_rows, &score))//If clear row animation finished
  0299 e689         [3]     LDAB  9,SP
  029b 37           [2]     PSHB  
  029c e6f018       [3]     LDAB  24,SP
  029f 37           [2]     PSHB  
  02a0 1af011       [2]     LEAX  17,SP
  02a3 b754         [1]     TFR   X,D
  02a5 160000       [4]     JSR   clearing_row_animation
  02a8 1b82         [2]     LEAS  2,SP
  02aa 044199       [3]     TBEQ  B,*+156 ;abs = 0346
  310:  				{
  311:  					if (is_game_over())//might still be game over after clearing
  02ad 160000       [4]     JSR   is_game_over
  02b0 044108       [3]     TBEQ  B,*+11 ;abs = 02bb
  312:  						current_state = GAME_FINISHED_ANIMATION;
  02b3 c606         [1]     LDAB  #6
  02b5 87           [1]     CLRA  
  02b6 6c8d         [2]     STD   13,SP
  02b8 060000       [3]     JMP   main:0x0346
  313:  					else
  314:  					{
  315:  						place_falling_piece(x = DROP_XCORD, y = DROP_YCORD, piece = (rand() % TOTAL_PIECES) + 1, rotation = rand() % TOTAL_ORIENTATIONS);//cambiar por and dsp
  02bb c602         [1]     LDAB  #2
  02bd 6b8a         [2]     STAB  10,SP
  02bf 87           [1]     CLRA  
  02c0 3b           [2]     PSHD  
  02c1 57           [1]     ASRB  
  02c2 6b8b         [2]     STAB  11,SP
  02c4 3b           [2]     PSHD  
  02c5 160000       [4]     JSR   rand
  02c8 ce0007       [2]     LDX   #7
  02cb 1815         [12]    IDIVS 
  02cd c30001       [2]     ADDD  #1
  02d0 6c8f         [2]     STD   15,SP
  02d2 3b           [2]     PSHD  
  02d3 160000       [4]     JSR   rand
  02d6 ce0004       [2]     LDX   #4
  02d9 1815         [12]    IDIVS 
  02db 6c86         [2]     STD   6,SP
  02dd 160000       [4]     JSR   place_falling_piece
  02e0 1b86         [2]     LEAS  6,SP
  316:  						current_state = NORMAL_PLAY;
  02e2 c603         [1]     LDAB  #3
  02e4 87           [1]     CLRA  
  02e5 6c8d         [2]     STD   13,SP
  317:  						piece_fall_time = ((score / SCORE_LEVEL_UP) < NUMBER_SPEEDS) ? game_speed[score / SCORE_LEVEL_UP] : game_speed[NUMBER_SPEEDS - 1];
  02e7 c6c8         [1]     LDAB  #200
  02e9 3b           [2]     PSHD  
  02ea c7           [1]     CLRB  
  02eb 3b           [2]     PSHD  
  02ec ecf015       [3]     LDD   21,SP
  02ef eef013       [3]     LDX   19,SP
  02f2 160000       [4]     JSR   _LDIVU
  02f5 cd0010       [2]     LDY   #16
  02f8 35           [2]     PSHY  
  02f9 18c7         [2]     CLRY  
  02fb 35           [2]     PSHY  
  02fc 160000       [4]     JSR   _LCMP
  02ff 2505         [3/1]   BCS   *+7 ;abs = 0306
  0301 fd0000       [3]     LDY   game_speed:30
  0304 2007         [3]     BRA   *+9 ;abs = 030d
  0306 59           [1]     LSLD  
  0307 b745         [1]     TFR   D,X
  0309 ede20000     [4]     LDY   game_speed,X
  030d 6df013       [3]     STY   19,SP
  318:  						set_timer_period_ms(TIMER_0, piece_fall_time);//FALL TIME
  0310 c7           [1]     CLRB  
  0311 37           [2]     PSHB  
  0312 b764         [1]     TFR   Y,D
  0314 160000       [4]     JSR   set_timer_period_ms
  0317 1b81         [2]     LEAS  1,SP
  319:  						send_number_display(score);
  0319 ecf011       [3]     LDD   17,SP
  031c ee8f         [3]     LDX   15,SP
  031e 160000       [4]     JSR   send_number_display
  320:  						update_all_display_data();
  0321 160000       [4]     JSR   update_all_display_data
  0324 2020         [3]     BRA   *+34 ;abs = 0346
  321:  					}
  322:  				}
  323:  				redraw = 1;
  324:  			}
  325:  			break;
  326:  
  327:  		case GAME_PAUSED:
  328:  			if (ev.id == TIMER)
  0326 e682         [3]     LDAB  2,SP
  0328 c103         [1]     CMPB  #3
  032a 261c         [3/1]   BNE   *+30 ;abs = 0348
  329:  			{
  330:  				set_timer_period_ms(TIMER_0, 400);
  032c c7           [1]     CLRB  
  032d 37           [2]     PSHB  
  032e cc0190       [2]     LDD   #400
  0331 160000       [4]     JSR   set_timer_period_ms
  0334 1b81         [2]     LEAS  1,SP
  331:  				game_pause_animation(x, y, piece, rotation);
  0336 e68a         [3]     LDAB  10,SP
  0338 37           [2]     PSHB  
  0339 e68a         [3]     LDAB  10,SP
  033b 37           [2]     PSHB  
  033c ec8d         [3]     LDD   13,SP
  033e 3b           [2]     PSHD  
  033f ec84         [3]     LDD   4,SP
  0341 160000       [4]     JSR   game_pause_animation
  0344 1b84         [2]     LEAS  4,SP
  0346 207d         [3]     BRA   *+127 ;abs = 03c5
  332:  				redraw = 1;
  333:  			}
  334:  			else if (ev.id == BUTTON_PRESS && ev.data == BUTTON_6) //Resumes games
  0348 04612b       [3]     TBNE  B,*+46 ;abs = 0376
  034b e683         [3]     LDAB  3,SP
  034d c106         [1]     CMPB  #6
  034f 2625         [3/1]   BNE   *+39 ;abs = 0376
  335:  			{
  336:  				set_timer_period_ms(TIMER_0, piece_fall_time);
  0351 c7           [1]     CLRB  
  0352 37           [2]     PSHB  
  0353 ecf014       [3]     LDD   20,SP
  0356 160000       [4]     JSR   set_timer_period_ms
  0359 1b81         [2]     LEAS  1,SP
  337:  				place_falling_piece(x, y, piece, rotation);
  035b e68a         [3]     LDAB  10,SP
  035d b715         [1]     SEX   B,X
  035f 34           [2]     PSHX  
  0360 e68b         [3]     LDAB  11,SP
  0362 b715         [1]     SEX   B,X
  0364 34           [2]     PSHX  
  0365 ec8f         [3]     LDD   15,SP
  0367 3b           [2]     PSHD  
  0368 ec86         [3]     LDD   6,SP
  036a 160000       [4]     JSR   place_falling_piece
  036d 1b86         [2]     LEAS  6,SP
  338:  				update_all_display_data();
  036f 160000       [4]     JSR   update_all_display_data
  339:  				current_state = NORMAL_PLAY; //RESUME_GAME 
  0372 c603         [1]     LDAB  #3
  340:  			}
  0374 2020         [3]     BRA   *+34 ;abs = 0396
  341:  			else if (ev.id == BUTTON_PRESS && ev.data == BUTTON_7) // Reset game
  0376 e682         [3]     LDAB  2,SP
  0378 2646         [3/1]   BNE   *+72 ;abs = 03c0
  037a e683         [3]     LDAB  3,SP
  037c c107         [1]     CMPB  #7
  037e 2640         [3/1]   BNE   *+66 ;abs = 03c0
  342:  			{
  343:  				place_falling_piece(x, y, piece, rotation);
  0380 e68a         [3]     LDAB  10,SP
  0382 b715         [1]     SEX   B,X
  0384 34           [2]     PSHX  
  0385 e68b         [3]     LDAB  11,SP
  0387 b715         [1]     SEX   B,X
  0389 34           [2]     PSHX  
  038a ec8f         [3]     LDD   15,SP
  038c 3b           [2]     PSHD  
  038d ec86         [3]     LDD   6,SP
  038f 160000       [4]     JSR   place_falling_piece
  0392 1b86         [2]     LEAS  6,SP
  344:  				current_state = GAME_FINISHED_ANIMATION;
  0394 c606         [1]     LDAB  #6
  0396 87           [1]     CLRA  
  0397 6c8d         [2]     STD   13,SP
  0399 2025         [3]     BRA   *+39 ;abs = 03c0
  345:  
  346:  			}
  347:  			break;
  348:  
  349:  
  350:  		case GAME_FINISHED_ANIMATION:
  351:  			if (ev.id == TIMER)
  039b e682         [3]     LDAB  2,SP
  039d c103         [1]     CMPB  #3
  039f 261f         [3/1]   BNE   *+33 ;abs = 03c0
  352:  			{
  353:  				if (game_end_animation(&y, piece))
  03a1 1a89         [2]     LEAX  9,SP
  03a3 34           [2]     PSHX  
  03a4 ec8d         [3]     LDD   13,SP
  03a6 160000       [4]     JSR   game_end_animation
  03a9 1b82         [2]     LEAS  2,SP
  03ab 04410d       [3]     TBEQ  B,*+16 ;abs = 03bb
  354:  				{
  355:  					set_timer_period_ms(TIMER_0, 50);//So that the animation happens faster
  03ae c7           [1]     CLRB  
  03af 37           [2]     PSHB  
  03b0 c632         [1]     LDAB  #50
  03b2 87           [1]     CLRA  
  03b3 160000       [4]     JSR   set_timer_period_ms
  03b6 1b81         [2]     LEAS  1,SP
  356:  					current_state = PRE_START;
  03b8 18698d       [3]     CLRW  13,SP
  357:  				}
  358:  				redraw = 1;
  03bb c601         [1]     LDAB  #1
  03bd 6bf016       [3]     STAB  22,SP
  359:  			}
  360:  			break;
  361:  
  362:  
  363:  		case MAIN_MENU:
  364:  
  365:  			break;
  366:  		}
  367:  
  368:  
  369:  		if (redraw && !get_total_events_in_queue())  //This is important.
  03c0 e6f016       [3]     LDAB  22,SP
  03c3 270c         [3/1]   BEQ   *+14 ;abs = 03d1
  03c5 160000       [4]     JSR   get_total_events_in_queue
  03c8 046406       [3]     TBNE  D,*+9 ;abs = 03d1
  370:  		{
  371:  			update_display_data();
  03cb 160000       [4]     JSR   update_display_data
  372:  			//Each interrupt takes place every 50ms
  373:  			//Each display update takes about 20 ~ 25 ms
  374:  			//So let's make sure that if display needs to be updated
  375:  			//update only happens once every 50ms period.
  376:  			//So, there are about 25ms left for other things!
  377:  			//We want to have some spare time, just waiting for new events,
  378:  			//so that next interrupt arrives when display is not being updated.
  379:  			//else, interrupt will be postponed (interrupts are disabled while sending data),
  380:  			//and so will events!
  381:  			LEDdisplay_update();
  03ce 160000       [4]     JSR   LEDdisplay_update
  382:  			redraw = 0;
  383:  		}
  384:  	}
  03d1 060000       [3]     JMP   main:0x00c4
  385:  	for (;;);
  386:  
  387:  	return 0; //Do not reach this line!
  388:  }
  389:  
  390:  void game_pause_animation(signed char x, unsigned char y, piece_type_t piece_type, rotation_t rotation)
  391:  {
*** EVALUATION ***

Function: game_pause_animation
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  392:  	static unsigned char count = 0;
  393:  	if (count & 0x01) //If it's an odd number
  0001 1f00000113   [5]     BRCLR count,#1,*+24 ;abs = 0019
  394:  		remove_piece(x, y, piece_type, rotation);
  0006 e687         [3]     LDAB  7,SP
  0008 b715         [1]     SEX   B,X
  000a 34           [2]     PSHX  
  000b e688         [3]     LDAB  8,SP
  000d 87           [1]     CLRA  
  000e 3b           [2]     PSHD  
  000f ec88         [3]     LDD   8,SP
  0011 3b           [2]     PSHD  
  0012 ec86         [3]     LDD   6,SP
  0014 160000       [4]     JSR   remove_piece
  0017 2011         [3]     BRA   *+19 ;abs = 002a
  395:  	else
  396:  		place_falling_piece(x, y, piece_type, rotation);
  0019 e687         [3]     LDAB  7,SP
  001b b715         [1]     SEX   B,X
  001d 34           [2]     PSHX  
  001e e688         [3]     LDAB  8,SP
  0020 87           [1]     CLRA  
  0021 3b           [2]     PSHD  
  0022 ec88         [3]     LDD   8,SP
  0024 3b           [2]     PSHD  
  0025 ec86         [3]     LDD   6,SP
  0027 160000       [4]     JSR   place_falling_piece
  397:  	count++;
  002a 720000       [4]     INC   count
  398:  }
  002d 1b88         [2]     LEAS  8,SP
  002f 3d           [5]     RTS   
  399:  /*
  400:  * This function uses the clock of the microprocessor to seed the rand function
  401:  *	Receives and returns void/nothing
  402:  *
  403:  */
  404:  
  405:  void seed_rand(void)    //Call this after initializing everything!
  406:  {
*** EVALUATION ***

Function: seed_rand
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 1b9e         [2]     LEAS  -2,SP
  407:  	EVENT_T ev;
  408:  	do wait_for_event(&ev);
  0002 1a80         [2]     LEAX  0,SP
  0004 b754         [1]     TFR   X,D
  0006 160000       [4]     JSR   wait_for_event
  409:  	while (ev.id != BUTTON_PRESS);  //Wait for button down
  0009 e680         [3]     LDAB  0,SP
  000b 26f5         [3/1]   BNE   *-9 ;abs = 0002
  410:  	srand(TCNT);                    //A different number every 50ns should be "random" enough
  000d dc00         [3]     LDD   _TCNT
  000f 160000       [4]     JSR   srand
  411:  }
  0012 1b82         [2]     LEAS  2,SP
  0014 3d           [5]     RTS   
  412:  
  413:  /*
  414:  * Clears the whole to board game to a selected block_t
  415:  *  Receive value:
  416:  *   -block_to_clear : The block which will be set in the whole board
  417:  */
  418:  void clear_board_to_block(block_t block_to_clear)
  419:  {
*** EVALUATION ***

Function: clear_board_to_block
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6bad         [2]     STAB  3,-SP
  420:  	int x, y;
  421:  	block_to_clear.redraw = 1;
  0002 0c8002       [4]     BSET  0,SP,#2
  422:  	for (y = 0; y < DISPLAY_HEIGHT + HIDDEN_ROWS; y++)
  0005 186981       [3]     CLRW  1,SP
  423:  		for (x = 0; x < DISPLAY_WIDTH + HIDDEN_ROWS; x++)
  0008 1887         [2]     CLRX  
  424:  			(*board[y])[x] = block_to_clear;
  000a ed81         [3]     LDY   1,SP
  000c 1858         [2]     LSLY  
  000e 34           [2]     PSHX  
  000f 18abea0000   [5]     ADDX  board,Y
  0014 e682         [3]     LDAB  2,SP
  0016 6b00         [2]     STAB  0,X
  0018 30           [3]     PULX  
  0019 08           [1]     INX   
  001a 8e000c       [2]     CPX   #12
  001d 2deb         [3/1]   BLT   *-19 ;abs = 000a
  001f 186281       [4]     INCW  1,SP
  0022 ec81         [3]     LDD   1,SP
  0024 8c0024       [2]     CPD   #36
  0027 2ddf         [3/1]   BLT   *-31 ;abs = 0008
  425:  }
  0029 1b83         [2]     LEAS  3,SP
  002b 3d           [5]     RTS   
  426:  
  427:  /*
  428:  * Update the whole Leddisplay matrix(which stores the corresponding values in rgb)
  429:  * only those blocks which have the redraw flag set.
  430:  *	 Receives and returns void/nothing
  431:  */
  432:  void update_display_data(void)
  433:  {
*** EVALUATION ***

Function: update_display_data
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 1b99         [2]     LEAS  -7,SP
  434:  	unsigned char x, y;
  435:  	for (y = 0; y < DISPLAY_HEIGHT; y++)
  0002 6986         [2]     CLR   6,SP
  436:  		for (x = 0; x < DISPLAY_WIDTH; x++)
  0004 6985         [2]     CLR   5,SP
  437:  			if ((*board[HIDDEN_ROWS + y])[x].redraw)
  0006 e686         [3]     LDAB  6,SP
  0008 87           [1]     CLRA  
  0009 59           [1]     LSLD  
  000a b745         [1]     TFR   D,X
  000c e685         [3]     LDAB  5,SP
  000e 87           [1]     CLRA  
  000f 6c81         [2]     STD   1,SP
  0011 e3e20000     [4]     ADDD  board:8,X
  0015 b746         [1]     TFR   D,Y
  0017 0f40023c     [4]     BRCLR 0,Y,#2,*+64 ;abs = 0057
  438:  			{
  439:  				//LEDdisplay_set_pixel(x, y, piece_color[(*board[y + HIDDEN_ROWS])[x].piece_type]);
  440:  				LEDdisplay_set_pixel(x, y, piece_color[(unsigned char)(*board[y + HIDDEN_ROWS])[x].piece_type]);
  001b e685         [3]     LDAB  5,SP
  001d 37           [2]     PSHB  
  001e e687         [3]     LDAB  7,SP
  0020 37           [2]     PSHB  
  0021 ec83         [3]     LDD   3,SP
  0023 e3e20000     [4]     ADDD  board:8,X
  0027 b746         [1]     TFR   D,Y
  0029 e640         [3]     LDAB  0,Y
  002b c4e0         [1]     ANDB  #224
  002d 54           [1]     LSRB  
  002e 54           [1]     LSRB  
  002f 54           [1]     LSRB  
  0030 54           [1]     LSRB  
  0031 54           [1]     LSRB  
  0032 6b82         [2]     STAB  2,SP
  0034 c603         [1]     LDAB  #3
  0036 a682         [3]     LDAA  2,SP
  0038 12           [1]     MUL   
  0039 b746         [1]     TFR   D,Y
  003b 6e85         [2]     STX   5,SP
  003d eeea0000     [4]     LDX   piece_color:1,Y
  0041 e6ea0000     [4]     LDAB  piece_color,Y
  0045 160000       [4]     JSR   LEDdisplay_set_pixel
  0048 1b82         [2]     LEAS  2,SP
  441:  				(*board[y + HIDDEN_ROWS])[x].redraw = 0;
  004a ee83         [3]     LDX   3,SP
  004c ec81         [3]     LDD   1,SP
  004e e3e20000     [4]     ADDD  board:8,X
  0052 b745         [1]     TFR   D,X
  0054 0d0002       [4]     BCLR  0,X,#2
  0057 6285         [3]     INC   5,SP
  0059 e685         [3]     LDAB  5,SP
  005b c108         [1]     CMPB  #8
  005d 25a7         [3/1]   BCS   *-87 ;abs = 0006
  005f 6286         [3]     INC   6,SP
  0061 e686         [3]     LDAB  6,SP
  0063 c120         [1]     CMPB  #32
  0065 259d         [3/1]   BCS   *-97 ;abs = 0004
  442:  			}
  443:  }
  0067 1b87         [2]     LEAS  7,SP
  0069 3d           [5]     RTS   
  444:  /*
  445:  * Update the whole Leddisplay matrix(which stores the corresponding values in rgb)
  446:  * all blocks are reset even those with the redraw flag not set(value in 0).
  447:  *	 Receives and returns void/nothing
  448:  */
  449:  void update_all_display_data(void)
  450:  {
*** EVALUATION ***

Function: update_all_display_data
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  451:  	unsigned char x, y;
  452:  	for (y = 0; y < DISPLAY_HEIGHT; y++)
  0000 69af         [2]     CLR   1,-SP
  453:  		for (x = 0; x < DISPLAY_WIDTH; x++)
  0002 c7           [1]     CLRB  
  454:  			(*board[y + HIDDEN_ROWS])[x].redraw = 1;
  0003 37           [2]     PSHB  
  0004 e681         [3]     LDAB  1,SP
  0006 87           [1]     CLRA  
  0007 59           [1]     LSLD  
  0008 b745         [1]     TFR   D,X
  000a e680         [3]     LDAB  0,SP
  000c 87           [1]     CLRA  
  000d e3e20000     [4]     ADDD  board:8,X
  0011 b745         [1]     TFR   D,X
  0013 0c0002       [4]     BSET  0,X,#2
  0016 33           [3]     PULB  
  0017 52           [1]     INCB  
  0018 c108         [1]     CMPB  #8
  001a 25e7         [3/1]   BCS   *-23 ;abs = 0003
  001c 6280         [3]     INC   0,SP
  001e e680         [3]     LDAB  0,SP
  0020 c120         [1]     CMPB  #32
  0022 25de         [3/1]   BCS   *-32 ;abs = 0002
  455:  
  456:  	update_display_data();
  0024 160000       [4]     JSR   update_display_data
  457:  }
  0027 1b81         [2]     LEAS  1,SP
  0029 3d           [5]     RTS   
  458:  
  459:  const unsigned int reverse_bit_flag[] =  //For optimization, faster than shifts
  460:  {
  461:  	0x8000,0x4000,0x2000,0x1000,0x0800,0x0400,0x0200,0x0100,0x0080,0x0040,0x0020,0x0010,0x0008,0x0004,0x0002,0x0001
  462:  };
  463:  
  464:  /*
  465:  * This function receives cords INSIDE THE PIECE_CONTAINER_SIZE (4x4) and returns 1 if the cord has a block piece in it
  466:  *	Receive_value:
  467:  *		piece_x: x_cord of the tetris piece [0,3]
  468:  *		piece_y: y_cord of the tetris piece [0,3]
  469:  *		piece_type: Piece type I,L,S,Z,etc
  470:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  471:  * Return value:
  472:  *		bool, 1 if the cord has a piece block. 0 if empty piece.
  473:  */
  474:  unsigned char get_piece_data(signed int piece_x, unsigned int piece_y, piece_type_t piece_type, rotation_t rotation)
  475:  {
*** EVALUATION ***

Function: get_piece_data
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  476:  	if (piece_x >= PIECE_CONTAINER_SIZE || piece_y >= PIECE_CONTAINER_SIZE || piece_type > TOTAL_PIECES || rotation >= TOTAL_ORIENTATIONS)
  0001 ec88         [3]     LDD   8,SP
  0003 8c0004       [2]     CPD   #4
  0006 2c15         [3/1]   BGE   *+23 ;abs = 001d
  0008 ec86         [3]     LDD   6,SP
  000a 8c0004       [2]     CPD   #4
  000d 240e         [3/1]   BCC   *+16 ;abs = 001d
  000f ec84         [3]     LDD   4,SP
  0011 8c0007       [2]     CPD   #7
  0014 2e07         [3/1]   BGT   *+9 ;abs = 001d
  0016 ec80         [3]     LDD   0,SP
  0018 8c0004       [2]     CPD   #4
  001b 2d03         [3/1]   BLT   *+5 ;abs = 0020
  477:  		return 0;
  001d c7           [1]     CLRB  
  001e 2025         [3]     BRA   *+39 ;abs = 0045
  478:  	return (tetris_pieces[piece_type][rotation] & reverse_bit_flag[(4 * (piece_y)) + piece_x]) ? 1 : 0;
  0020 ec86         [3]     LDD   6,SP
  0022 59           [1]     LSLD  
  0023 59           [1]     LSLD  
  0024 e388         [3]     ADDD  8,SP
  0026 59           [1]     LSLD  
  0027 b746         [1]     TFR   D,Y
  0029 ec84         [3]     LDD   4,SP
  002b 59           [1]     LSLD  
  002c 59           [1]     LSLD  
  002d 59           [1]     LSLD  
  002e ee80         [3]     LDX   0,SP
  0030 1848         [2]     LSLX  
  0032 1ae6         [2]     LEAX  D,X
  0034 34           [2]     PSHX  
  0035 eeea0000     [4]     LDX   reverse_bit_flag,Y
  0039 31           [3]     PULY  
  003a 18a4ea0000   [5]     ANDX  tetris_pieces,Y
  003f 2602         [3/1]   BNE   *+4 ;abs = 0043
  0041 c7           [1]     CLRB  
  0042 8f           [2]     SKIP2 
  0043 c601         [1]     LDAB  #1
  479:  }
  0045 1b82         [2]     LEAS  2,SP
  0047 3d           [5]     RTS   
  480:  
  481:  /*
  482:  * This function tells you if a piece can be placed at certain cordinates.
  483:  * Receive_value:
  484:  *		piece_x: x_cord of the board where the tetris piece is trying to be placed.
  485:  *		piece_y: x_cord of the board where the tetris piece is trying to be placed.
  486:  *		piece_type: Piece type I,L,S,Z,etc
  487:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  488:  * Return value:
  489:  *		bool: 1 if the piece can be placed 0 if it can not be placed.
  490:  */
  491:  unsigned char can_place_piece(signed int x, unsigned int y, piece_type_t piece_type, rotation_t rotation)
  492:  {
*** EVALUATION ***

Function: can_place_piece
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6caa         [2]     STD   6,-SP
  493:  	int piece_x, piece_y;
  494:  	for (piece_y = 0; piece_y < PIECE_CONTAINER_SIZE; piece_y++)
  0002 186984       [3]     CLRW  4,SP
  495:  		for (piece_x = 0; piece_x < PIECE_CONTAINER_SIZE; piece_x++)
  0005 186982       [3]     CLRW  2,SP
  496:  			if (
  0008 ec82         [3]     LDD   2,SP
  000a 3b           [2]     PSHD  
  000b ec86         [3]     LDD   6,SP
  000d 3b           [2]     PSHD  
  000e ec8c         [3]     LDD   12,SP
  0010 3b           [2]     PSHD  
  0011 ec86         [3]     LDD   6,SP
  0013 0700         [4]     BSR   get_piece_data
  0015 1b86         [2]     LEAS  6,SP
  0017 04412a       [3]     TBEQ  B,*+45 ;abs = 0044
  497:  				get_piece_data(piece_x, piece_y, piece_type, rotation) &&
  498:  				(
  499:  					x + piece_x >= DISPLAY_WIDTH ||
  500:  					x + piece_x<0 ||
  501:  					y + piece_y >= DISPLAY_HEIGHT + HIDDEN_ROWS ||
  502:  					y + piece_y<0 ||
  001a ee8c         [3]     LDX   12,SP
  001c 18ab82       [4]     ADDX  2,SP
  001f 8e0008       [2]     CPX   #8
  0022 2c1d         [3/1]   BGE   *+31 ;abs = 0041
  0024 1897         [2]     TSTX  
  0026 2d19         [3/1]   BLT   *+27 ;abs = 0041
  0028 ed8a         [3]     LDY   10,SP
  002a 18eb84       [4]     ADDY  4,SP
  002d 8d0024       [2]     CPY   #36
  0030 240f         [3/1]   BCC   *+17 ;abs = 0041
  503:  					(
  504:  					((*board[y + piece_y])[x + piece_x].piece_type != NO_PIECE) &&
  0032 1858         [2]     LSLY  
  0034 18abea0000   [5]     ADDX  board,Y
  0039 0f00e007     [4]     BRCLR 0,X,#224,*+11 ;abs = 0044
  505:  						!(*board[y + piece_y])[x + piece_x].fall_piece
  003d 0e000103     [4]     BRSET 0,X,#1,*+7 ;abs = 0044
  506:  						)
  507:  
  508:  					)
  509:  				)//If place is in use return false lazy || so no segfault
  510:  				return 0;
  0041 c7           [1]     CLRB  
  0042 2016         [3]     BRA   *+24 ;abs = 005a
  0044 186282       [4]     INCW  2,SP
  0047 ec82         [3]     LDD   2,SP
  0049 8c0004       [2]     CPD   #4
  004c 2dba         [3/1]   BLT   *-68 ;abs = 0008
  004e 186284       [4]     INCW  4,SP
  0051 ec84         [3]     LDD   4,SP
  0053 8c0004       [2]     CPD   #4
  0056 2dad         [3/1]   BLT   *-81 ;abs = 0005
  511:  	return 1;
  0058 c601         [1]     LDAB  #1
  512:  }
  005a 1b86         [2]     LEAS  6,SP
  005c 3d           [5]     RTS   
  513:  /*
  514:  * This function tells you if a piece can be removed at certain cordinates.
  515:  * Receive_value:
  516:  *		piece_x: x_cord of the board where the tetris piece is to be removed.
  517:  *		piece_y: x_cord of the board where the tetris piece is to be removed.
  518:  *		piece_type: Piece type I,L,S,Z,etc
  519:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  520:  * Return value:
  521:  *		bool: 1 if the piece can be placed 0 if it can not be placed.
  522:  */
  523:  void remove_piece(signed int x, unsigned int y, piece_type_t piece_type, rotation_t rotation)
  524:  {
*** EVALUATION ***

Function: remove_piece
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6ca9         [2]     STD   7,-SP
  525:  	int piece_x, piece_y;
  526:  	block_t empty;
  527:  	empty.redraw = 1; empty.fall_piece = 0; empty.piece_type = NO_PIECE;
  0002 0d86e1       [4]     BCLR  6,SP,#225
  0005 0c8602       [4]     BSET  6,SP,#2
  528:  	for (piece_y = 0; piece_y < 4; piece_y++)
  0008 186984       [3]     CLRW  4,SP
  529:  		for (piece_x = 0; piece_x < 4; piece_x++)
  000b 186982       [3]     CLRW  2,SP
  530:  			if (get_piece_data(piece_x, piece_y, piece_type, rotation))
  000e ec82         [3]     LDD   2,SP
  0010 3b           [2]     PSHD  
  0011 ec86         [3]     LDD   6,SP
  0013 3b           [2]     PSHD  
  0014 ec8d         [3]     LDD   13,SP
  0016 3b           [2]     PSHD  
  0017 ec86         [3]     LDD   6,SP
  0019 160000       [4]     JSR   get_piece_data
  001c 1b86         [2]     LEAS  6,SP
  001e 044115       [3]     TBEQ  B,*+24 ;abs = 0036
  531:  				(*board[y + piece_y])[x + piece_x] = empty;
  0021 ee8b         [3]     LDX   11,SP
  0023 18ab84       [4]     ADDX  4,SP
  0026 1848         [2]     LSLX  
  0028 ed8d         [3]     LDY   13,SP
  002a 18eb82       [4]     ADDY  2,SP
  002d 18ebe20000   [5]     ADDY  board,X
  0032 e686         [3]     LDAB  6,SP
  0034 6b40         [2]     STAB  0,Y
  0036 186282       [4]     INCW  2,SP
  0039 ec82         [3]     LDD   2,SP
  003b 8c0004       [2]     CPD   #4
  003e 2dce         [3/1]   BLT   *-48 ;abs = 000e
  0040 186284       [4]     INCW  4,SP
  0043 ec84         [3]     LDD   4,SP
  0045 8c0004       [2]     CPD   #4
  0048 2dc1         [3/1]   BLT   *-61 ;abs = 000b
  532:  
  533:  }
  004a 1b87         [2]     LEAS  7,SP
  004c 3d           [5]     RTS   
  534:  /*
  535:  * This function places an active piece at certain cords(falling piece flag 1). (ASSUMES THAT IT CAN BE PLACED CALL can_place_piece beforehand)
  536:  * Receive_value:
  537:  *		piece_x: x_cord of the board where the tetris piece is going to be placed.
  538:  *		piece_y: x_cord of the board where the tetris piece is going to be placed.
  539:  *		piece_type: Piece type I,L,S,Z,etc
  540:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  541:  * Return value:
  542:  *		void
  543:  */
  544:  void place_falling_piece(signed int x, unsigned int y, piece_type_t piece_type, rotation_t rotation)
  545:  {
*** EVALUATION ***

Function: place_falling_piece
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6ca9         [2]     STD   7,-SP
  546:  	int piece_x, piece_y;
  547:  	block_t falling_piece;
  548:  	falling_piece.fall_piece = 1;
  549:  	falling_piece.redraw = 1;
  0002 0c8603       [4]     BSET  6,SP,#3
  550:  	falling_piece.piece_type = piece_type;
  0005 c620         [1]     LDAB  #32
  0007 a68a         [3]     LDAA  10,SP
  0009 12           [1]     MUL   
  000a e886         [3]     EORB  6,SP
  000c c4e0         [1]     ANDB  #224
  000e e886         [3]     EORB  6,SP
  0010 6b86         [2]     STAB  6,SP
  551:  	for (piece_y = 0; piece_y < 4; piece_y++)
  0012 186984       [3]     CLRW  4,SP
  552:  		for (piece_x = 0; piece_x < 4; piece_x++)
  0015 186982       [3]     CLRW  2,SP
  553:  			if (get_piece_data(piece_x, piece_y, piece_type, rotation))
  0018 ec82         [3]     LDD   2,SP
  001a 3b           [2]     PSHD  
  001b ec86         [3]     LDD   6,SP
  001d 3b           [2]     PSHD  
  001e ec8d         [3]     LDD   13,SP
  0020 3b           [2]     PSHD  
  0021 ec86         [3]     LDD   6,SP
  0023 160000       [4]     JSR   get_piece_data
  0026 1b86         [2]     LEAS  6,SP
  0028 044115       [3]     TBEQ  B,*+24 ;abs = 0040
  554:  				(*board[y + piece_y])[x + piece_x] = falling_piece;
  002b ee8b         [3]     LDX   11,SP
  002d 18ab84       [4]     ADDX  4,SP
  0030 1848         [2]     LSLX  
  0032 ed8d         [3]     LDY   13,SP
  0034 18eb82       [4]     ADDY  2,SP
  0037 18ebe20000   [5]     ADDY  board,X
  003c e686         [3]     LDAB  6,SP
  003e 6b40         [2]     STAB  0,Y
  0040 186282       [4]     INCW  2,SP
  0043 ec82         [3]     LDD   2,SP
  0045 8c0004       [2]     CPD   #4
  0048 2dce         [3/1]   BLT   *-48 ;abs = 0018
  004a 186284       [4]     INCW  4,SP
  004d ec84         [3]     LDD   4,SP
  004f 8c0004       [2]     CPD   #4
  0052 2dc1         [3/1]   BLT   *-61 ;abs = 0015
  555:  }
  0054 1b87         [2]     LEAS  7,SP
  0056 3d           [5]     RTS   
  556:  
  557:  /*
  558:  * Places a static piece at certain cords(falling piece flag 0). (ASSUMES THAT IT CAN BE PLACED CALL can_place_piece beforehand)
  559:  * Receive_value:
  560:  *		piece_x: x_cord of the board where the tetris piece is going to be placed.
  561:  *		piece_y: x_cord of the board where the tetris piece is going to be placed.
  562:  *		piece_type: Piece type I,L,S,Z,etc
  563:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  564:  * Return value:
  565:  *		void
  566:  */
  567:  void place_static_piece(signed int x, unsigned int y, piece_type_t piece_type, rotation_t rotation)
  568:  {
*** EVALUATION ***

Function: place_static_piece
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6cab         [2]     STD   5,-SP
  0002 1b9c         [2]     LEAS  -4,SP
  569:  	unsigned char piece_x, piece_y;
  570:  	block_t static_piece;
  571:  	static_piece.redraw = 1;
  0004 0c8602       [4]     BSET  6,SP,#2
  572:  	static_piece.fall_piece = 0;
  0007 0d8601       [4]     BCLR  6,SP,#1
  573:  	static_piece.piece_type = piece_type;
  000a c620         [1]     LDAB  #32
  000c a68c         [3]     LDAA  12,SP
  000e 12           [1]     MUL   
  000f e886         [3]     EORB  6,SP
  0011 c4e0         [1]     ANDB  #224
  0013 e886         [3]     EORB  6,SP
  0015 6b86         [2]     STAB  6,SP
  574:  	for (piece_y = 0; piece_y < 4; piece_y++)
  0017 6988         [2]     CLR   8,SP
  575:  		for (piece_x = 0; piece_x < 4; piece_x++)
  0019 6987         [2]     CLR   7,SP
  576:  			if (get_piece_data(piece_x, piece_y, piece_type, rotation))
  001b e687         [3]     LDAB  7,SP
  001d 87           [1]     CLRA  
  001e 3b           [2]     PSHD  
  001f 6c82         [2]     STD   2,SP
  0021 e68a         [3]     LDAB  10,SP
  0023 3b           [2]     PSHD  
  0024 ee8f         [3]     LDX   15,SP
  0026 34           [2]     PSHX  
  0027 6c88         [2]     STD   8,SP
  0029 ec8a         [3]     LDD   10,SP
  002b 160000       [4]     JSR   get_piece_data
  002e 1b86         [2]     LEAS  6,SP
  0030 044115       [3]     TBEQ  B,*+24 ;abs = 0048
  577:  				(*board[y + piece_y])[x + piece_x] = static_piece;
  0033 ec82         [3]     LDD   2,SP
  0035 e38d         [3]     ADDD  13,SP
  0037 59           [1]     LSLD  
  0038 ee80         [3]     LDX   0,SP
  003a 18ab8f       [4]     ADDX  15,SP
  003d b746         [1]     TFR   D,Y
  003f 18abea0000   [5]     ADDX  board,Y
  0044 e686         [3]     LDAB  6,SP
  0046 6b00         [2]     STAB  0,X
  0048 6287         [3]     INC   7,SP
  004a e687         [3]     LDAB  7,SP
  004c c104         [1]     CMPB  #4
  004e 25cb         [3/1]   BCS   *-51 ;abs = 001b
  0050 6288         [3]     INC   8,SP
  0052 e688         [3]     LDAB  8,SP
  0054 c104         [1]     CMPB  #4
  0056 25c1         [3/1]   BCS   *-61 ;abs = 0019
  578:  }
  0058 1b89         [2]     LEAS  9,SP
  005a 3d           [5]     RTS   
  579:  
  580:  /*
  581:  * JAJAJA NO ENTENDIA NADA CUANDO LA VI, DIJE CUANDO LA HICE YO :D -Rama -.-
  582:  *
  583:  */
  584:  unsigned char move_piece_up(signed char x, signed char y, piece_type_t piece_type, rotation_t rotation)
  585:  {
*** EVALUATION ***

Function: move_piece_up
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  0001 1b9a         [2]     LEAS  -6,SP
  586:  	//I make this functions just because I can! and for testing purposes
  587:  	if (can_place_piece(x, y - 1, piece_type, rotation))
  0003 e68d         [3]     LDAB  13,SP
  0005 b715         [1]     SEX   B,X
  0007 34           [2]     PSHX  
  0008 e68e         [3]     LDAB  14,SP
  000a b716         [1]     SEX   B,Y
  000c 6e82         [2]     STX   2,SP
  000e 1a5f         [2]     LEAX  -1,Y
  0010 34           [2]     PSHX  
  0011 ec8e         [3]     LDD   14,SP
  0013 3b           [2]     PSHD  
  0014 ec8c         [3]     LDD   12,SP
  0016 6d88         [2]     STY   8,SP
  0018 6e8a         [2]     STX   10,SP
  001a 160000       [4]     JSR   can_place_piece
  001d 1b86         [2]     LEAS  6,SP
  001f 044120       [3]     TBEQ  B,*+35 ;abs = 0042
  588:  	{
  589:  		remove_piece(x, y, piece_type, rotation);
  0022 ec80         [3]     LDD   0,SP
  0024 3b           [2]     PSHD  
  0025 ee84         [3]     LDX   4,SP
  0027 34           [2]     PSHX  
  0028 ee8e         [3]     LDX   14,SP
  002a 34           [2]     PSHX  
  002b ec8c         [3]     LDD   12,SP
  002d 160000       [4]     JSR   remove_piece
  590:  		place_falling_piece(x, y - 1, piece_type, rotation);
  0030 eca5         [3]     LDD   6,+SP
  0032 3b           [2]     PSHD  
  0033 ec86         [3]     LDD   6,SP
  0035 3b           [2]     PSHD  
  0036 ec8e         [3]     LDD   14,SP
  0038 3b           [2]     PSHD  
  0039 ec8c         [3]     LDD   12,SP
  003b 160000       [4]     JSR   place_falling_piece
  003e 1b86         [2]     LEAS  6,SP
  591:  		return 1;
  0040 c601         [1]     LDAB  #1
  592:  	}
  593:  	else
  594:  		return 0;
  595:  
  596:  }
  0042 1b88         [2]     LEAS  8,SP
  0044 3d           [5]     RTS   
  597:  
  598:  /*
  599:  * This function moves an active piece at certain cords 1 row down(falling piece flag 1).
  600:  * Receive_value:
  601:  *		piece_x: x_cord of the board where the tetris piece is going to be moved.
  602:  *		piece_y: x_cord of the board where the tetris piece is going to be moved.
  603:  *		piece_type: Piece type I,L,S,Z,etc
  604:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  605:  * Return value:
  606:  *		bool : True(1) if it can be moved down, false(0) if it cannot be placed.
  607:  */
  608:  unsigned char move_piece_down(signed char x, signed char y, piece_type_t piece_type, rotation_t rotation)
  609:  {
*** EVALUATION ***

Function: move_piece_down
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  0001 1b9a         [2]     LEAS  -6,SP
  610:  	if (can_place_piece(x, y + 1, piece_type, rotation))
  0003 e68d         [3]     LDAB  13,SP
  0005 b715         [1]     SEX   B,X
  0007 34           [2]     PSHX  
  0008 e68e         [3]     LDAB  14,SP
  000a b716         [1]     SEX   B,Y
  000c 6e82         [2]     STX   2,SP
  000e 1a41         [2]     LEAX  1,Y
  0010 34           [2]     PSHX  
  0011 ec8e         [3]     LDD   14,SP
  0013 3b           [2]     PSHD  
  0014 ec8c         [3]     LDD   12,SP
  0016 6d88         [2]     STY   8,SP
  0018 6e8a         [2]     STX   10,SP
  001a 160000       [4]     JSR   can_place_piece
  001d 1b86         [2]     LEAS  6,SP
  001f 044120       [3]     TBEQ  B,*+35 ;abs = 0042
  611:  	{
  612:  		remove_piece(x, y, piece_type, rotation);
  0022 ec80         [3]     LDD   0,SP
  0024 3b           [2]     PSHD  
  0025 ee84         [3]     LDX   4,SP
  0027 34           [2]     PSHX  
  0028 ee8e         [3]     LDX   14,SP
  002a 34           [2]     PSHX  
  002b ec8c         [3]     LDD   12,SP
  002d 160000       [4]     JSR   remove_piece
  613:  		place_falling_piece(x, y + 1, piece_type, rotation);
  0030 eca5         [3]     LDD   6,+SP
  0032 3b           [2]     PSHD  
  0033 ec86         [3]     LDD   6,SP
  0035 3b           [2]     PSHD  
  0036 ec8e         [3]     LDD   14,SP
  0038 3b           [2]     PSHD  
  0039 ec8c         [3]     LDD   12,SP
  003b 160000       [4]     JSR   place_falling_piece
  003e 1b86         [2]     LEAS  6,SP
  614:  		return 1;
  0040 c601         [1]     LDAB  #1
  615:  	}
  616:  	else
  617:  		return 0;
  618:  
  619:  }
  0042 1b88         [2]     LEAS  8,SP
  0044 3d           [5]     RTS   
  620:  
  621:  /*
  622:  * This function moves an active piece at certain cords 1 column to the left (falling piece flag 1).
  623:  * Receive_value:
  624:  *		piece_x: x_cord of the board where the tetris piece is going to be moved.
  625:  *		piece_y: x_cord of the board where the tetris piece is going to be moved.
  626:  *		piece_type: Piece type I,L,S,Z,etc
  627:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  628:  * Return value:
  629:  *		bool : True(1) if it can be moved left, false(0) if it cannot be placed.
  630:  */
  631:  unsigned char move_piece_left(signed char x, signed char y, piece_type_t piece_type, rotation_t rotation)
  632:  {
*** EVALUATION ***

Function: move_piece_left
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  0001 1b9a         [2]     LEAS  -6,SP
  633:  	if (can_place_piece(x - 1, y, piece_type, rotation))
  0003 e68d         [3]     LDAB  13,SP
  0005 b715         [1]     SEX   B,X
  0007 191f         [2]     LEAY  -1,X
  0009 35           [2]     PSHY  
  000a e68e         [3]     LDAB  14,SP
  000c b714         [1]     SEX   B,D
  000e 3b           [2]     PSHD  
  000f 6c84         [2]     STD   4,SP
  0011 ec8e         [3]     LDD   14,SP
  0013 3b           [2]     PSHD  
  0014 ec8c         [3]     LDD   12,SP
  0016 6d88         [2]     STY   8,SP
  0018 6e8a         [2]     STX   10,SP
  001a 160000       [4]     JSR   can_place_piece
  001d 1b86         [2]     LEAS  6,SP
  001f 044122       [3]     TBEQ  B,*+37 ;abs = 0044
  634:  	{
  635:  		remove_piece(x, y, piece_type, rotation);
  0022 ec84         [3]     LDD   4,SP
  0024 3b           [2]     PSHD  
  0025 ec82         [3]     LDD   2,SP
  0027 3b           [2]     PSHD  
  0028 ee8e         [3]     LDX   14,SP
  002a 34           [2]     PSHX  
  002b ec8c         [3]     LDD   12,SP
  002d 160000       [4]     JSR   remove_piece
  0030 1b86         [2]     LEAS  6,SP
  636:  		place_falling_piece(x - 1, y, piece_type, rotation);
  0032 ec82         [3]     LDD   2,SP
  0034 3b           [2]     PSHD  
  0035 ec82         [3]     LDD   2,SP
  0037 3b           [2]     PSHD  
  0038 ec8e         [3]     LDD   14,SP
  003a 3b           [2]     PSHD  
  003b ec8c         [3]     LDD   12,SP
  003d 160000       [4]     JSR   place_falling_piece
  0040 1b86         [2]     LEAS  6,SP
  637:  		return 1;
  0042 c601         [1]     LDAB  #1
  638:  	}
  639:  	else
  640:  		return 0;
  641:  
  642:  }
  0044 1b88         [2]     LEAS  8,SP
  0046 3d           [5]     RTS   
  643:  /*
  644:  * This function moves an active piece at certain cords 1 column to the right (falling piece flag 1).
  645:  * Receive_value:
  646:  *		piece_x: x_cord of the board where the tetris piece is going to be moved.
  647:  *		piece_y: x_cord of the board where the tetris piece is going to be moved.
  648:  *		piece_type: Piece type I,L,S,Z,etc
  649:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  650:  * Return value:
  651:  *		bool : True(1) if it can be moved right, false(0) if it cannot be placed.
  652:  */
  653:  unsigned char move_piece_right(signed char x, signed char y, piece_type_t piece_type, rotation_t rotation)
  654:  {
*** EVALUATION ***

Function: move_piece_right
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  0001 1b9a         [2]     LEAS  -6,SP
  655:  	if (can_place_piece(x + 1, y, piece_type, rotation))
  0003 e68d         [3]     LDAB  13,SP
  0005 b715         [1]     SEX   B,X
  0007 1901         [2]     LEAY  1,X
  0009 35           [2]     PSHY  
  000a e68e         [3]     LDAB  14,SP
  000c b714         [1]     SEX   B,D
  000e 3b           [2]     PSHD  
  000f 6c84         [2]     STD   4,SP
  0011 ec8e         [3]     LDD   14,SP
  0013 3b           [2]     PSHD  
  0014 ec8c         [3]     LDD   12,SP
  0016 6d88         [2]     STY   8,SP
  0018 6e8a         [2]     STX   10,SP
  001a 160000       [4]     JSR   can_place_piece
  001d 1b86         [2]     LEAS  6,SP
  001f 044122       [3]     TBEQ  B,*+37 ;abs = 0044
  656:  	{
  657:  		remove_piece(x, y, piece_type, rotation);
  0022 ec84         [3]     LDD   4,SP
  0024 3b           [2]     PSHD  
  0025 ec82         [3]     LDD   2,SP
  0027 3b           [2]     PSHD  
  0028 ee8e         [3]     LDX   14,SP
  002a 34           [2]     PSHX  
  002b ec8c         [3]     LDD   12,SP
  002d 160000       [4]     JSR   remove_piece
  0030 1b86         [2]     LEAS  6,SP
  658:  		place_falling_piece(x + 1, y, piece_type, rotation);
  0032 ec82         [3]     LDD   2,SP
  0034 3b           [2]     PSHD  
  0035 ec82         [3]     LDD   2,SP
  0037 3b           [2]     PSHD  
  0038 ec8e         [3]     LDD   14,SP
  003a 3b           [2]     PSHD  
  003b ec8c         [3]     LDD   12,SP
  003d 160000       [4]     JSR   place_falling_piece
  0040 1b86         [2]     LEAS  6,SP
  659:  		return 1;
  0042 c601         [1]     LDAB  #1
  660:  	}
  661:  	else
  662:  		return 0;
  663:  
  664:  }
  0044 1b88         [2]     LEAS  8,SP
  0046 3d           [5]     RTS   
  665:  /*
  666:  * This function rotates an active piece(falling piece flag 1) at certain cords clockwise .
  667:  * Receive_value:
  668:  *		piece_x: x_cord of the board where the tetris piece is going to be rotated.
  669:  *		piece_y: x_cord of the board where the tetris piece is going to be rotated.
  670:  *		piece_type: Piece type I,L,S,Z,etc
  671:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  672:  * Return value:
  673:  *		bool : True(1) if it can be rotated, false(0) if it cannot be rotated.
  674:  *
  675:  * THIS FUNCTION MODIFIES X, Y AND ROTATION
  676:  */
  677:  unsigned char rotate_piece_clockwise(signed char * x, signed char * y, piece_type_t *piece_type, rotation_t * rotation)
  678:  {
*** EVALUATION ***

Function: rotate_piece_clockwise
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  0001 1b9e         [2]     LEAS  -2,SP
  679:  	//TO_DO: IMPLEMENT COMPLEX ROTATION!
  680:  	if (can_place_piece(*x, *y, *piece_type, ((*rotation) + 1) & 0x03))
  0003 ee8a         [3]     LDX   10,SP
  0005 e600         [3]     LDAB  0,X
  0007 b716         [1]     SEX   B,Y
  0009 35           [2]     PSHY  
  000a ed8a         [3]     LDY   10,SP
  000c e640         [3]     LDAB  0,Y
  000e b714         [1]     SEX   B,D
  0010 3b           [2]     PSHD  
  0011 ee8a         [3]     LDX   10,SP
  0013 ec00         [3]     LDD   0,X
  0015 3b           [2]     PSHD  
  0016 ee88         [3]     LDX   8,SP
  0018 e601         [3]     LDAB  1,X
  001a 52           [1]     INCB  
  001b c403         [1]     ANDB  #3
  001d 87           [1]     CLRA  
  001e 160000       [4]     JSR   can_place_piece
  0021 1b86         [2]     LEAS  6,SP
  0023 04413f       [3]     TBEQ  B,*+66 ;abs = 0065
  681:  	{
  682:  		remove_piece(*x, *y, *piece_type, *rotation);
  0026 ee8a         [3]     LDX   10,SP
  0028 e600         [3]     LDAB  0,X
  002a b716         [1]     SEX   B,Y
  002c 35           [2]     PSHY  
  002d ed8a         [3]     LDY   10,SP
  002f e640         [3]     LDAB  0,Y
  0031 b715         [1]     SEX   B,X
  0033 34           [2]     PSHX  
  0034 ee8a         [3]     LDX   10,SP
  0036 ec00         [3]     LDD   0,X
  0038 3b           [2]     PSHD  
  0039 ee88         [3]     LDX   8,SP
  003b ec00         [3]     LDD   0,X
  003d 160000       [4]     JSR   remove_piece
  0040 1b86         [2]     LEAS  6,SP
  683:  		place_falling_piece(*x, *y, *piece_type, ((*rotation) + 1) & 0x03);
  0042 ee8a         [3]     LDX   10,SP
  0044 e600         [3]     LDAB  0,X
  0046 b715         [1]     SEX   B,X
  0048 34           [2]     PSHX  
  0049 ee8a         [3]     LDX   10,SP
  004b e600         [3]     LDAB  0,X
  004d b715         [1]     SEX   B,X
  004f 34           [2]     PSHX  
  0050 ee8a         [3]     LDX   10,SP
  0052 ec00         [3]     LDD   0,X
  0054 3b           [2]     PSHD  
  0055 ee88         [3]     LDX   8,SP
  0057 e601         [3]     LDAB  1,X
  0059 52           [1]     INCB  
  005a c403         [1]     ANDB  #3
  005c 87           [1]     CLRA  
  005d 160000       [4]     JSR   place_falling_piece
  0060 1b86         [2]     LEAS  6,SP
  684:  		(*rotation) = ((*rotation) + 1) & 0x03;
  685:  		return 1;
  0062 060000       [3]     JMP   rotate_piece_clockwise:0x022b
  686:  	}
  687:  	else if (*x < 0 && can_place_piece((*x) + 1, *y, *piece_type, ((*rotation) + 1) & 0x03))
  0065 ee8a         [3]     LDX   10,SP
  0067 e600         [3]     LDAB  0,X
  0069 2c64         [3/1]   BGE   *+102 ;abs = 00cf
  006b b716         [1]     SEX   B,Y
  006d 02           [1]     INY   
  006e 35           [2]     PSHY  
  006f ed8a         [3]     LDY   10,SP
  0071 e640         [3]     LDAB  0,Y
  0073 b715         [1]     SEX   B,X
  0075 34           [2]     PSHX  
  0076 ee8a         [3]     LDX   10,SP
  0078 ec00         [3]     LDD   0,X
  007a 3b           [2]     PSHD  
  007b ee88         [3]     LDX   8,SP
  007d e601         [3]     LDAB  1,X
  007f 52           [1]     INCB  
  0080 c403         [1]     ANDB  #3
  0082 87           [1]     CLRA  
  0083 160000       [4]     JSR   can_place_piece
  0086 1b86         [2]     LEAS  6,SP
  0088 044144       [3]     TBEQ  B,*+71 ;abs = 00cf
  688:  	{
  689:  		remove_piece(*x, *y, *piece_type, *rotation);
  008b ee8a         [3]     LDX   10,SP
  008d e600         [3]     LDAB  0,X
  008f b716         [1]     SEX   B,Y
  0091 35           [2]     PSHY  
  0092 ed8a         [3]     LDY   10,SP
  0094 e640         [3]     LDAB  0,Y
  0096 b715         [1]     SEX   B,X
  0098 34           [2]     PSHX  
  0099 ee8a         [3]     LDX   10,SP
  009b ec00         [3]     LDD   0,X
  009d 3b           [2]     PSHD  
  009e ee88         [3]     LDX   8,SP
  00a0 ec00         [3]     LDD   0,X
  00a2 160000       [4]     JSR   remove_piece
  00a5 1b86         [2]     LEAS  6,SP
  690:  		place_falling_piece((*x) + 1, *y, *piece_type, ((*rotation) + 1) & 0x03);
  00a7 ee8a         [3]     LDX   10,SP
  00a9 e600         [3]     LDAB  0,X
  00ab b716         [1]     SEX   B,Y
  00ad 02           [1]     INY   
  00ae 35           [2]     PSHY  
  00af ed8a         [3]     LDY   10,SP
  00b1 e640         [3]     LDAB  0,Y
  00b3 b716         [1]     SEX   B,Y
  00b5 35           [2]     PSHY  
  00b6 ed8a         [3]     LDY   10,SP
  00b8 ec40         [3]     LDD   0,Y
  00ba 3b           [2]     PSHD  
  00bb ed88         [3]     LDY   8,SP
  00bd e641         [3]     LDAB  1,Y
  00bf 52           [1]     INCB  
  00c0 c403         [1]     ANDB  #3
  00c2 87           [1]     CLRA  
  00c3 160000       [4]     JSR   place_falling_piece
  00c6 1b86         [2]     LEAS  6,SP
  691:  		(*x)++;
  00c8 ee8a         [3]     LDX   10,SP
  00ca 6200         [3]     INC   0,X
  692:  		(*rotation) = ((*rotation) + 1) & 0x03;
  693:  		return 1;
  00cc 060000       [3]     JMP   rotate_piece_clockwise:0x022b
  694:  	}
  695:  	else if (*x >(DISPLAY_WIDTH - PIECE_CONTAINER_SIZE) && can_place_piece((*x) - 1, *y, *piece_type, ((*rotation) + 1) & 0x03))
  00cf ee8a         [3]     LDX   10,SP
  00d1 e600         [3]     LDAB  0,X
  00d3 c104         [1]     CMPB  #4
  00d5 2f64         [3/1]   BLE   *+102 ;abs = 013b
  00d7 b716         [1]     SEX   B,Y
  00d9 03           [1]     DEY   
  00da 35           [2]     PSHY  
  00db ed8a         [3]     LDY   10,SP
  00dd e640         [3]     LDAB  0,Y
  00df b714         [1]     SEX   B,D
  00e1 3b           [2]     PSHD  
  00e2 ee8a         [3]     LDX   10,SP
  00e4 ec00         [3]     LDD   0,X
  00e6 3b           [2]     PSHD  
  00e7 ee88         [3]     LDX   8,SP
  00e9 e601         [3]     LDAB  1,X
  00eb 52           [1]     INCB  
  00ec c403         [1]     ANDB  #3
  00ee 87           [1]     CLRA  
  00ef 160000       [4]     JSR   can_place_piece
  00f2 1b86         [2]     LEAS  6,SP
  00f4 044144       [3]     TBEQ  B,*+71 ;abs = 013b
  696:  	{
  697:  		remove_piece(*x, *y, *piece_type, *rotation);
  00f7 ee8a         [3]     LDX   10,SP
  00f9 e600         [3]     LDAB  0,X
  00fb b716         [1]     SEX   B,Y
  00fd 35           [2]     PSHY  
  00fe ed8a         [3]     LDY   10,SP
  0100 e640         [3]     LDAB  0,Y
  0102 b715         [1]     SEX   B,X
  0104 34           [2]     PSHX  
  0105 ee8a         [3]     LDX   10,SP
  0107 ec00         [3]     LDD   0,X
  0109 3b           [2]     PSHD  
  010a ee88         [3]     LDX   8,SP
  010c ec00         [3]     LDD   0,X
  010e 160000       [4]     JSR   remove_piece
  0111 1b86         [2]     LEAS  6,SP
  698:  		place_falling_piece((*x) - 1, *y, *piece_type, ((*rotation) + 1) & 0x03);
  0113 ee8a         [3]     LDX   10,SP
  0115 e600         [3]     LDAB  0,X
  0117 b716         [1]     SEX   B,Y
  0119 03           [1]     DEY   
  011a 35           [2]     PSHY  
  011b ed8a         [3]     LDY   10,SP
  011d e640         [3]     LDAB  0,Y
  011f b716         [1]     SEX   B,Y
  0121 35           [2]     PSHY  
  0122 ed8a         [3]     LDY   10,SP
  0124 ec40         [3]     LDD   0,Y
  0126 3b           [2]     PSHD  
  0127 ed88         [3]     LDY   8,SP
  0129 e641         [3]     LDAB  1,Y
  012b 52           [1]     INCB  
  012c c403         [1]     ANDB  #3
  012e 87           [1]     CLRA  
  012f 160000       [4]     JSR   place_falling_piece
  0132 1b86         [2]     LEAS  6,SP
  699:  		(*x)--;
  0134 ee8a         [3]     LDX   10,SP
  0136 6300         [3]     DEC   0,X
  700:  		(*rotation) = ((*rotation) + 1) & 0x03;
  701:  		return 1;
  0138 060000       [3]     JMP   rotate_piece_clockwise:0x022b
  702:  	}
  703:  	else if (*piece_type == PIECE_I && *x < -1 && can_place_piece((*x) + 2, *y, *piece_type, ((*rotation) + 1) & 0x03))
  013b ee86         [3]     LDX   6,SP
  013d ec00         [3]     LDD   0,X
  013f 8c0001       [2]     CPD   #1
  0142 266f         [3/1]   BNE   *+113 ;abs = 01b3
  0144 ed8a         [3]     LDY   10,SP
  0146 6c80         [2]     STD   0,SP
  0148 e640         [3]     LDAB  0,Y
  014a c1ff         [1]     CMPB  #255
  014c 2c65         [3/1]   BGE   *+103 ;abs = 01b3
  014e b715         [1]     SEX   B,X
  0150 1a02         [2]     LEAX  2,X
  0152 34           [2]     PSHX  
  0153 ee8a         [3]     LDX   10,SP
  0155 e600         [3]     LDAB  0,X
  0157 b714         [1]     SEX   B,D
  0159 3b           [2]     PSHD  
  015a ec84         [3]     LDD   4,SP
  015c 3b           [2]     PSHD  
  015d ee88         [3]     LDX   8,SP
  015f e601         [3]     LDAB  1,X
  0161 52           [1]     INCB  
  0162 c403         [1]     ANDB  #3
  0164 87           [1]     CLRA  
  0165 160000       [4]     JSR   can_place_piece
  0168 1b86         [2]     LEAS  6,SP
  016a 044146       [3]     TBEQ  B,*+73 ;abs = 01b3
  704:  	{
  705:  		remove_piece(*x, *y, *piece_type, *rotation);
  016d ee8a         [3]     LDX   10,SP
  016f e600         [3]     LDAB  0,X
  0171 b716         [1]     SEX   B,Y
  0173 35           [2]     PSHY  
  0174 ed8a         [3]     LDY   10,SP
  0176 e640         [3]     LDAB  0,Y
  0178 b715         [1]     SEX   B,X
  017a 34           [2]     PSHX  
  017b ee8a         [3]     LDX   10,SP
  017d ec00         [3]     LDD   0,X
  017f 3b           [2]     PSHD  
  0180 ee88         [3]     LDX   8,SP
  0182 ec00         [3]     LDD   0,X
  0184 160000       [4]     JSR   remove_piece
  0187 1b86         [2]     LEAS  6,SP
  706:  		place_falling_piece((*x) + 2, *y, *piece_type, ((*rotation) + 1) & 0x03);
  0189 ee8a         [3]     LDX   10,SP
  018b e600         [3]     LDAB  0,X
  018d b716         [1]     SEX   B,Y
  018f 1942         [2]     LEAY  2,Y
  0191 35           [2]     PSHY  
  0192 ed8a         [3]     LDY   10,SP
  0194 e640         [3]     LDAB  0,Y
  0196 b716         [1]     SEX   B,Y
  0198 35           [2]     PSHY  
  0199 ed8a         [3]     LDY   10,SP
  019b ec40         [3]     LDD   0,Y
  019d 3b           [2]     PSHD  
  019e ed88         [3]     LDY   8,SP
  01a0 e641         [3]     LDAB  1,Y
  01a2 52           [1]     INCB  
  01a3 c403         [1]     ANDB  #3
  01a5 87           [1]     CLRA  
  01a6 160000       [4]     JSR   place_falling_piece
  01a9 1b86         [2]     LEAS  6,SP
  707:  		(*x) += 2;
  01ab ee8a         [3]     LDX   10,SP
  01ad e600         [3]     LDAB  0,X
  01af cb02         [1]     ADDB  #2
  708:  		(*rotation) = ((*rotation) + 1) & 0x03;
  709:  		return 1;
  01b1 2076         [3]     BRA   *+120 ;abs = 0229
  710:  
  711:  	}
  712:  	else if (*piece_type == PIECE_I && *x >(DISPLAY_WIDTH - 3) && can_place_piece((*x) - 2, *y, *piece_type, ((*rotation) + 1) & 0x03))
  01b3 ee86         [3]     LDX   6,SP
  01b5 ec00         [3]     LDD   0,X
  01b7 8c0001       [2]     CPD   #1
  01ba 267c         [3/1]   BNE   *+126 ;abs = 0238
  01bc ed8a         [3]     LDY   10,SP
  01be 6c80         [2]     STD   0,SP
  01c0 e640         [3]     LDAB  0,Y
  01c2 c105         [1]     CMPB  #5
  01c4 2f72         [3/1]   BLE   *+116 ;abs = 0238
  01c6 b715         [1]     SEX   B,X
  01c8 1a1e         [2]     LEAX  -2,X
  01ca 34           [2]     PSHX  
  01cb ee8a         [3]     LDX   10,SP
  01cd e600         [3]     LDAB  0,X
  01cf b714         [1]     SEX   B,D
  01d1 3b           [2]     PSHD  
  01d2 ec84         [3]     LDD   4,SP
  01d4 3b           [2]     PSHD  
  01d5 ee88         [3]     LDX   8,SP
  01d7 e601         [3]     LDAB  1,X
  01d9 52           [1]     INCB  
  01da c403         [1]     ANDB  #3
  01dc 87           [1]     CLRA  
  01dd 160000       [4]     JSR   can_place_piece
  01e0 1b86         [2]     LEAS  6,SP
  01e2 044153       [3]     TBEQ  B,*+86 ;abs = 0238
  713:  	{
  714:  		remove_piece(*x, *y, *piece_type, *rotation);
  01e5 ee8a         [3]     LDX   10,SP
  01e7 e600         [3]     LDAB  0,X
  01e9 b716         [1]     SEX   B,Y
  01eb 35           [2]     PSHY  
  01ec ed8a         [3]     LDY   10,SP
  01ee e640         [3]     LDAB  0,Y
  01f0 b715         [1]     SEX   B,X
  01f2 34           [2]     PSHX  
  01f3 ee8a         [3]     LDX   10,SP
  01f5 ec00         [3]     LDD   0,X
  01f7 3b           [2]     PSHD  
  01f8 ee88         [3]     LDX   8,SP
  01fa ec00         [3]     LDD   0,X
  01fc 160000       [4]     JSR   remove_piece
  01ff 1b86         [2]     LEAS  6,SP
  715:  		place_falling_piece((*x) - 2, *y, *piece_type, ((*rotation) + 1) & 0x03);
  0201 ee8a         [3]     LDX   10,SP
  0203 e600         [3]     LDAB  0,X
  0205 b716         [1]     SEX   B,Y
  0207 195e         [2]     LEAY  -2,Y
  0209 35           [2]     PSHY  
  020a ed8a         [3]     LDY   10,SP
  020c e640         [3]     LDAB  0,Y
  020e b716         [1]     SEX   B,Y
  0210 35           [2]     PSHY  
  0211 ed8a         [3]     LDY   10,SP
  0213 ec40         [3]     LDD   0,Y
  0215 3b           [2]     PSHD  
  0216 ed88         [3]     LDY   8,SP
  0218 e641         [3]     LDAB  1,Y
  021a 52           [1]     INCB  
  021b c403         [1]     ANDB  #3
  021d 87           [1]     CLRA  
  021e 160000       [4]     JSR   place_falling_piece
  0221 1b86         [2]     LEAS  6,SP
  716:  		(*x) -= 2;
  0223 ee8a         [3]     LDX   10,SP
  0225 e600         [3]     LDAB  0,X
  0227 c002         [1]     SUBB  #2
  0229 6b00         [2]     STAB  0,X
  717:  		(*rotation) = ((*rotation) + 1) & 0x03;
  022b ee82         [3]     LDX   2,SP
  022d e601         [3]     LDAB  1,X
  022f 52           [1]     INCB  
  0230 c403         [1]     ANDB  #3
  0232 87           [1]     CLRA  
  0233 6c00         [2]     STD   0,X
  718:  		return 1;
  0235 c601         [1]     LDAB  #1
  0237 21           [1]     SKIP1 
  719:  	}
  720:  	else
  721:  		return 0;
  0238 c7           [1]     CLRB  
  722:  }
  0239 1b84         [2]     LEAS  4,SP
  023b 3d           [5]     RTS   
  723:  
  724:  /*
  725:  * This function rotates an active piece(falling piece flag 1) at certain cords COUNTERclockwise .
  726:  * Receive_value:
  727:  *		piece_x: x_cord of the board where the tetris piece is going to be rotated.
  728:  *		piece_y: x_cord of the board where the tetris piece is going to be rotated.
  729:  *		piece_type: Piece type I,L,S,Z,etc
  730:  *		rotation: The rotation of the piece (straight, upside_down, left,right)
  731:  * Return value:
  732:  *		bool : True(1) if it can be rotated, false(0) if it cannot be rotated.
  733:  *
  734:  * THIS FUNCTION MODIFIES X, Y AND ROTATION
  735:  */
  736:  unsigned char rotate_piece_counterclockwise(signed char * x, signed char * y, piece_type_t *piece_type, rotation_t * rotation)
  737:  {
*** EVALUATION ***

Function: rotate_piece_counterclockwise
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  0001 1b9e         [2]     LEAS  -2,SP
  738:  	//TO_DO: IMPLEMENT COMPLEX ROTATION!
  739:  	if (can_place_piece(*x, *y, *piece_type, ((*rotation) + 3) & 0x03))
  0003 ee8a         [3]     LDX   10,SP
  0005 e600         [3]     LDAB  0,X
  0007 b716         [1]     SEX   B,Y
  0009 35           [2]     PSHY  
  000a ed8a         [3]     LDY   10,SP
  000c e640         [3]     LDAB  0,Y
  000e b714         [1]     SEX   B,D
  0010 3b           [2]     PSHD  
  0011 ee8a         [3]     LDX   10,SP
  0013 ec00         [3]     LDD   0,X
  0015 3b           [2]     PSHD  
  0016 ee88         [3]     LDX   8,SP
  0018 e601         [3]     LDAB  1,X
  001a cb03         [1]     ADDB  #3
  001c c403         [1]     ANDB  #3
  001e 87           [1]     CLRA  
  001f 160000       [4]     JSR   can_place_piece
  0022 1b86         [2]     LEAS  6,SP
  0024 044140       [3]     TBEQ  B,*+67 ;abs = 0067
  740:  	{
  741:  		remove_piece(*x, *y, *piece_type, *rotation);
  0027 ee8a         [3]     LDX   10,SP
  0029 e600         [3]     LDAB  0,X
  002b b716         [1]     SEX   B,Y
  002d 35           [2]     PSHY  
  002e ed8a         [3]     LDY   10,SP
  0030 e640         [3]     LDAB  0,Y
  0032 b715         [1]     SEX   B,X
  0034 34           [2]     PSHX  
  0035 ee8a         [3]     LDX   10,SP
  0037 ec00         [3]     LDD   0,X
  0039 3b           [2]     PSHD  
  003a ee88         [3]     LDX   8,SP
  003c ec00         [3]     LDD   0,X
  003e 160000       [4]     JSR   remove_piece
  0041 1b86         [2]     LEAS  6,SP
  742:  		place_falling_piece(*x, *y, *piece_type, ((*rotation) + 3) & 0x03);
  0043 ee8a         [3]     LDX   10,SP
  0045 e600         [3]     LDAB  0,X
  0047 b715         [1]     SEX   B,X
  0049 34           [2]     PSHX  
  004a ee8a         [3]     LDX   10,SP
  004c e600         [3]     LDAB  0,X
  004e b715         [1]     SEX   B,X
  0050 34           [2]     PSHX  
  0051 ee8a         [3]     LDX   10,SP
  0053 ec00         [3]     LDD   0,X
  0055 3b           [2]     PSHD  
  0056 ee88         [3]     LDX   8,SP
  0058 e601         [3]     LDAB  1,X
  005a cb03         [1]     ADDB  #3
  005c c403         [1]     ANDB  #3
  005e 87           [1]     CLRA  
  005f 160000       [4]     JSR   place_falling_piece
  0062 1b86         [2]     LEAS  6,SP
  743:  		(*rotation) = ((*rotation) + 3) & 0x03;
  744:  		return 1;
  0064 060000       [3]     JMP   rotate_piece_counterclockwise:0x0235
  745:  	}
  746:  	else if (*x < 0 && can_place_piece((*x) + 1, *y, *piece_type, ((*rotation) + 3) & 0x03))
  0067 ee8a         [3]     LDX   10,SP
  0069 e600         [3]     LDAB  0,X
  006b 2c66         [3/1]   BGE   *+104 ;abs = 00d3
  006d b716         [1]     SEX   B,Y
  006f 02           [1]     INY   
  0070 35           [2]     PSHY  
  0071 ed8a         [3]     LDY   10,SP
  0073 e640         [3]     LDAB  0,Y
  0075 b715         [1]     SEX   B,X
  0077 34           [2]     PSHX  
  0078 ee8a         [3]     LDX   10,SP
  007a ec00         [3]     LDD   0,X
  007c 3b           [2]     PSHD  
  007d ee88         [3]     LDX   8,SP
  007f e601         [3]     LDAB  1,X
  0081 cb03         [1]     ADDB  #3
  0083 c403         [1]     ANDB  #3
  0085 87           [1]     CLRA  
  0086 160000       [4]     JSR   can_place_piece
  0089 1b86         [2]     LEAS  6,SP
  008b 044145       [3]     TBEQ  B,*+72 ;abs = 00d3
  747:  	{
  748:  		remove_piece(*x, *y, *piece_type, *rotation);
  008e ee8a         [3]     LDX   10,SP
  0090 e600         [3]     LDAB  0,X
  0092 b716         [1]     SEX   B,Y
  0094 35           [2]     PSHY  
  0095 ed8a         [3]     LDY   10,SP
  0097 e640         [3]     LDAB  0,Y
  0099 b715         [1]     SEX   B,X
  009b 34           [2]     PSHX  
  009c ee8a         [3]     LDX   10,SP
  009e ec00         [3]     LDD   0,X
  00a0 3b           [2]     PSHD  
  00a1 ee88         [3]     LDX   8,SP
  00a3 ec00         [3]     LDD   0,X
  00a5 160000       [4]     JSR   remove_piece
  00a8 1b86         [2]     LEAS  6,SP
  749:  		place_falling_piece((*x) + 1, *y, *piece_type, ((*rotation) + 3) & 0x03);
  00aa ee8a         [3]     LDX   10,SP
  00ac e600         [3]     LDAB  0,X
  00ae b716         [1]     SEX   B,Y
  00b0 02           [1]     INY   
  00b1 35           [2]     PSHY  
  00b2 ed8a         [3]     LDY   10,SP
  00b4 e640         [3]     LDAB  0,Y
  00b6 b716         [1]     SEX   B,Y
  00b8 35           [2]     PSHY  
  00b9 ed8a         [3]     LDY   10,SP
  00bb ec40         [3]     LDD   0,Y
  00bd 3b           [2]     PSHD  
  00be ed88         [3]     LDY   8,SP
  00c0 e641         [3]     LDAB  1,Y
  00c2 cb03         [1]     ADDB  #3
  00c4 c403         [1]     ANDB  #3
  00c6 87           [1]     CLRA  
  00c7 160000       [4]     JSR   place_falling_piece
  00ca 1b86         [2]     LEAS  6,SP
  750:  		(*x)++;
  00cc ee8a         [3]     LDX   10,SP
  00ce 6200         [3]     INC   0,X
  751:  		(*rotation) = ((*rotation) + 3) & 0x03;
  752:  		return 1;
  00d0 060000       [3]     JMP   rotate_piece_counterclockwise:0x0235
  753:  	}
  754:  	else if (*x >(DISPLAY_WIDTH - PIECE_CONTAINER_SIZE) && can_place_piece((*x) - 1, *y, *piece_type, ((*rotation) + 3) & 0x03))
  00d3 ee8a         [3]     LDX   10,SP
  00d5 e600         [3]     LDAB  0,X
  00d7 c104         [1]     CMPB  #4
  00d9 2f66         [3/1]   BLE   *+104 ;abs = 0141
  00db b716         [1]     SEX   B,Y
  00dd 03           [1]     DEY   
  00de 35           [2]     PSHY  
  00df ed8a         [3]     LDY   10,SP
  00e1 e640         [3]     LDAB  0,Y
  00e3 b714         [1]     SEX   B,D
  00e5 3b           [2]     PSHD  
  00e6 ee8a         [3]     LDX   10,SP
  00e8 ec00         [3]     LDD   0,X
  00ea 3b           [2]     PSHD  
  00eb ee88         [3]     LDX   8,SP
  00ed e601         [3]     LDAB  1,X
  00ef cb03         [1]     ADDB  #3
  00f1 c403         [1]     ANDB  #3
  00f3 87           [1]     CLRA  
  00f4 160000       [4]     JSR   can_place_piece
  00f7 1b86         [2]     LEAS  6,SP
  00f9 044145       [3]     TBEQ  B,*+72 ;abs = 0141
  755:  	{
  756:  		remove_piece(*x, *y, *piece_type, *rotation);
  00fc ee8a         [3]     LDX   10,SP
  00fe e600         [3]     LDAB  0,X
  0100 b716         [1]     SEX   B,Y
  0102 35           [2]     PSHY  
  0103 ed8a         [3]     LDY   10,SP
  0105 e640         [3]     LDAB  0,Y
  0107 b715         [1]     SEX   B,X
  0109 34           [2]     PSHX  
  010a ee8a         [3]     LDX   10,SP
  010c ec00         [3]     LDD   0,X
  010e 3b           [2]     PSHD  
  010f ee88         [3]     LDX   8,SP
  0111 ec00         [3]     LDD   0,X
  0113 160000       [4]     JSR   remove_piece
  0116 1b86         [2]     LEAS  6,SP
  757:  		place_falling_piece((*x) - 1, *y, *piece_type, ((*rotation) + 3) & 0x03);
  0118 ee8a         [3]     LDX   10,SP
  011a e600         [3]     LDAB  0,X
  011c b716         [1]     SEX   B,Y
  011e 03           [1]     DEY   
  011f 35           [2]     PSHY  
  0120 ed8a         [3]     LDY   10,SP
  0122 e640         [3]     LDAB  0,Y
  0124 b716         [1]     SEX   B,Y
  0126 35           [2]     PSHY  
  0127 ed8a         [3]     LDY   10,SP
  0129 ec40         [3]     LDD   0,Y
  012b 3b           [2]     PSHD  
  012c ed88         [3]     LDY   8,SP
  012e e641         [3]     LDAB  1,Y
  0130 cb03         [1]     ADDB  #3
  0132 c403         [1]     ANDB  #3
  0134 87           [1]     CLRA  
  0135 160000       [4]     JSR   place_falling_piece
  0138 1b86         [2]     LEAS  6,SP
  758:  		(*x)--;
  013a ee8a         [3]     LDX   10,SP
  013c 6300         [3]     DEC   0,X
  759:  		(*rotation) = ((*rotation) + 3) & 0x03;
  760:  		return 1;
  013e 060000       [3]     JMP   rotate_piece_counterclockwise:0x0235
  761:  	}
  762:  	else if (*piece_type == PIECE_I && *x < -1 && can_place_piece((*x) + 2, *y, *piece_type, ((*rotation) + 3) & 0x03))
  0141 ee86         [3]     LDX   6,SP
  0143 ec00         [3]     LDD   0,X
  0145 8c0001       [2]     CPD   #1
  0148 2671         [3/1]   BNE   *+115 ;abs = 01bb
  014a ed8a         [3]     LDY   10,SP
  014c 6c80         [2]     STD   0,SP
  014e e640         [3]     LDAB  0,Y
  0150 c1ff         [1]     CMPB  #255
  0152 2c67         [3/1]   BGE   *+105 ;abs = 01bb
  0154 b715         [1]     SEX   B,X
  0156 1a02         [2]     LEAX  2,X
  0158 34           [2]     PSHX  
  0159 ee8a         [3]     LDX   10,SP
  015b e600         [3]     LDAB  0,X
  015d b714         [1]     SEX   B,D
  015f 3b           [2]     PSHD  
  0160 ec84         [3]     LDD   4,SP
  0162 3b           [2]     PSHD  
  0163 ee88         [3]     LDX   8,SP
  0165 e601         [3]     LDAB  1,X
  0167 cb03         [1]     ADDB  #3
  0169 c403         [1]     ANDB  #3
  016b 87           [1]     CLRA  
  016c 160000       [4]     JSR   can_place_piece
  016f 1b86         [2]     LEAS  6,SP
  0171 044147       [3]     TBEQ  B,*+74 ;abs = 01bb
  763:  	{
  764:  		remove_piece(*x, *y, *piece_type, *rotation);
  0174 ee8a         [3]     LDX   10,SP
  0176 e600         [3]     LDAB  0,X
  0178 b716         [1]     SEX   B,Y
  017a 35           [2]     PSHY  
  017b ed8a         [3]     LDY   10,SP
  017d e640         [3]     LDAB  0,Y
  017f b715         [1]     SEX   B,X
  0181 34           [2]     PSHX  
  0182 ee8a         [3]     LDX   10,SP
  0184 ec00         [3]     LDD   0,X
  0186 3b           [2]     PSHD  
  0187 ee88         [3]     LDX   8,SP
  0189 ec00         [3]     LDD   0,X
  018b 160000       [4]     JSR   remove_piece
  018e 1b86         [2]     LEAS  6,SP
  765:  		place_falling_piece((*x) + 2, *y, *piece_type, ((*rotation) + 3) & 0x03);
  0190 ee8a         [3]     LDX   10,SP
  0192 e600         [3]     LDAB  0,X
  0194 b716         [1]     SEX   B,Y
  0196 1942         [2]     LEAY  2,Y
  0198 35           [2]     PSHY  
  0199 ed8a         [3]     LDY   10,SP
  019b e640         [3]     LDAB  0,Y
  019d b716         [1]     SEX   B,Y
  019f 35           [2]     PSHY  
  01a0 ed8a         [3]     LDY   10,SP
  01a2 ec40         [3]     LDD   0,Y
  01a4 3b           [2]     PSHD  
  01a5 ed88         [3]     LDY   8,SP
  01a7 e641         [3]     LDAB  1,Y
  01a9 cb03         [1]     ADDB  #3
  01ab c403         [1]     ANDB  #3
  01ad 87           [1]     CLRA  
  01ae 160000       [4]     JSR   place_falling_piece
  01b1 1b86         [2]     LEAS  6,SP
  766:  		(*x) += 2;
  01b3 ee8a         [3]     LDX   10,SP
  01b5 e600         [3]     LDAB  0,X
  01b7 cb02         [1]     ADDB  #2
  767:  		(*rotation) = ((*rotation) + 3) & 0x03;
  768:  		return 1;
  01b9 2078         [3]     BRA   *+122 ;abs = 0233
  769:  
  770:  	}
  771:  	else if (*piece_type == PIECE_I && *x >(DISPLAY_WIDTH - 3) && can_place_piece((*x) - 2, *y, *piece_type, ((*rotation) + 3) & 0x03))
  01bb ee86         [3]     LDX   6,SP
  01bd ec00         [3]     LDD   0,X
  01bf 8c0001       [2]     CPD   #1
  01c2 267f         [3/1]   BNE   *+129 ;abs = 0243
  01c4 ed8a         [3]     LDY   10,SP
  01c6 6c80         [2]     STD   0,SP
  01c8 e640         [3]     LDAB  0,Y
  01ca c105         [1]     CMPB  #5
  01cc 2f75         [3/1]   BLE   *+119 ;abs = 0243
  01ce b715         [1]     SEX   B,X
  01d0 1a1e         [2]     LEAX  -2,X
  01d2 34           [2]     PSHX  
  01d3 ee8a         [3]     LDX   10,SP
  01d5 e600         [3]     LDAB  0,X
  01d7 b714         [1]     SEX   B,D
  01d9 3b           [2]     PSHD  
  01da ec84         [3]     LDD   4,SP
  01dc 3b           [2]     PSHD  
  01dd ee88         [3]     LDX   8,SP
  01df e601         [3]     LDAB  1,X
  01e1 cb03         [1]     ADDB  #3
  01e3 c403         [1]     ANDB  #3
  01e5 87           [1]     CLRA  
  01e6 160000       [4]     JSR   can_place_piece
  01e9 1b86         [2]     LEAS  6,SP
  01eb 044155       [3]     TBEQ  B,*+88 ;abs = 0243
  772:  	{
  773:  		remove_piece(*x, *y, *piece_type, *rotation);
  01ee ee8a         [3]     LDX   10,SP
  01f0 e600         [3]     LDAB  0,X
  01f2 b716         [1]     SEX   B,Y
  01f4 35           [2]     PSHY  
  01f5 ed8a         [3]     LDY   10,SP
  01f7 e640         [3]     LDAB  0,Y
  01f9 b715         [1]     SEX   B,X
  01fb 34           [2]     PSHX  
  01fc ee8a         [3]     LDX   10,SP
  01fe ec00         [3]     LDD   0,X
  0200 3b           [2]     PSHD  
  0201 ee88         [3]     LDX   8,SP
  0203 ec00         [3]     LDD   0,X
  0205 160000       [4]     JSR   remove_piece
  0208 1b86         [2]     LEAS  6,SP
  774:  		place_falling_piece((*x) - 2, *y, *piece_type, ((*rotation) + 3) & 0x03);
  020a ee8a         [3]     LDX   10,SP
  020c e600         [3]     LDAB  0,X
  020e b716         [1]     SEX   B,Y
  0210 195e         [2]     LEAY  -2,Y
  0212 35           [2]     PSHY  
  0213 ed8a         [3]     LDY   10,SP
  0215 e640         [3]     LDAB  0,Y
  0217 b716         [1]     SEX   B,Y
  0219 35           [2]     PSHY  
  021a ed8a         [3]     LDY   10,SP
  021c ec40         [3]     LDD   0,Y
  021e 3b           [2]     PSHD  
  021f ed88         [3]     LDY   8,SP
  0221 e641         [3]     LDAB  1,Y
  0223 cb03         [1]     ADDB  #3
  0225 c403         [1]     ANDB  #3
  0227 87           [1]     CLRA  
  0228 160000       [4]     JSR   place_falling_piece
  022b 1b86         [2]     LEAS  6,SP
  775:  		(*x) -= 2;
  022d ee8a         [3]     LDX   10,SP
  022f e600         [3]     LDAB  0,X
  0231 c002         [1]     SUBB  #2
  0233 6b00         [2]     STAB  0,X
  776:  		(*rotation) = ((*rotation) + 3) & 0x03;
  0235 ee82         [3]     LDX   2,SP
  0237 e601         [3]     LDAB  1,X
  0239 cb03         [1]     ADDB  #3
  023b c403         [1]     ANDB  #3
  023d 87           [1]     CLRA  
  023e 6c00         [2]     STD   0,X
  777:  		return 1;
  0240 c601         [1]     LDAB  #1
  0242 21           [1]     SKIP1 
  778:  	}
  779:  	else
  780:  		return 0;
  0243 c7           [1]     CLRB  
  781:  }
  0244 1b84         [2]     LEAS  4,SP
  0246 3d           [5]     RTS   
  782:  
  783:  /*
  784:  * This function checks the four lines after y_cord (including the line in y_cord)
  785:  * to see if the are complete. This is useful to know when a piece is placed which lines
  786:  * need to be deleted.
  787:  *  Receive value:
  788:  *		top y_cord: Line from which the following 4 inclusive will be checked
  789:  *  Return value examples:
  790:  *   - 0000 0001		Only first row to be cleared
  791:  *   - 0000 0011		First and second rows to be cleared
  792:  *   - 0000 1000		Only forth row to be cleared
  793:  *
  794:  */
  795:  unsigned char check_cleared_rows(unsigned char y_cord)
  796:  {
*** EVALUATION ***

Function: check_cleared_rows
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6baa         [2]     STAB  6,-SP
  797:  	signed char x, y;
  798:  	unsigned char rows_to_clear = 0x00;
  0002 6983         [2]     CLR   3,SP
  799:  	char moving_mask = 0x01;
  0004 c601         [1]     LDAB  #1
  0006 6b84         [2]     STAB  4,SP
  800:  	char row_flag;
  801:  	//printf("Called with %d\n",y_cord);
  802:  	//sleep(1);
  803:  	for (y = y_cord; y < (DISPLAY_HEIGHT + HIDDEN_ROWS) && y < (y_cord + PIECE_CONTAINER_SIZE); y++, moving_mask <<= 1)
  0008 a680         [3]     LDAA  0,SP
  000a 6a82         [2]     STAA  2,SP
  000c 202f         [3]     BRA   *+49 ;abs = 003d
  804:  	{
  805:  		for (x = 0, row_flag = 1; x < DISPLAY_WIDTH; x++)
  000e 6981         [2]     CLR   1,SP
  0010 c601         [1]     LDAB  #1
  0012 6b85         [2]     STAB  5,SP
  806:  			if ((*board[y])[x].piece_type == NO_PIECE)
  0014 e682         [3]     LDAB  2,SP
  0016 b715         [1]     SEX   B,X
  0018 1848         [2]     LSLX  
  001a e681         [3]     LDAB  1,SP
  001c b716         [1]     SEX   B,Y
  001e 18ebe20000   [5]     ADDY  board,X
  0023 0f40e012     [4]     BRCLR 0,Y,#224,*+22 ;abs = 0039
  0027 6281         [3]     INC   1,SP
  0029 e681         [3]     LDAB  1,SP
  002b c108         [1]     CMPB  #8
  002d 2de5         [3/1]   BLT   *-25 ;abs = 0014
  807:  			{
  808:  				row_flag = 0;
  809:  				break;
  810:  			}
  811:  		if (row_flag)
  002f e685         [3]     LDAB  5,SP
  0031 2706         [3/1]   BEQ   *+8 ;abs = 0039
  812:  			rows_to_clear |= moving_mask;
  0033 a683         [3]     LDAA  3,SP
  0035 aa84         [3]     ORAA  4,SP
  0037 6a83         [2]     STAA  3,SP
  0039 6282         [3]     INC   2,SP
  003b 6884         [3]     LSL   4,SP
  003d e682         [3]     LDAB  2,SP
  003f c124         [1]     CMPB  #36
  0041 2c0d         [3/1]   BGE   *+15 ;abs = 0050
  0043 b715         [1]     SEX   B,X
  0045 e680         [3]     LDAB  0,SP
  0047 87           [1]     CLRA  
  0048 c30004       [2]     ADDD  #4
  004b 3b           [2]     PSHD  
  004c aeb1         [3]     CPX   2,SP+
  004e 2dbe         [3/1]   BLT   *-64 ;abs = 000e
  813:  
  814:  	}
  815:  	return rows_to_clear;
  0050 e683         [3]     LDAB  3,SP
  816:  
  817:  }
  0052 1b86         [2]     LEAS  6,SP
  0054 3d           [5]     RTS   
  818:  
  819:  
  820:  /*
  821:  * This function moves a line to the top of the array
  822:  * this includes the hidden rows so the row will be moved to the top hidden row.
  823:  *	Receive value:
  824:  *	 -line_row: the row in the array which will be move to the top row (first hidden row).
  825:  */
  826:  void move_line_to_top(unsigned char line_row)
  827:  {
*** EVALUATION ***

Function: move_line_to_top
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 37           [2]     PSHB  
  828:  	block_t(*temp_line)[DISPLAY_WIDTH];
  829:  	for (; line_row > 0; --line_row)
  0001 2016         [3]     BRA   *+24 ;abs = 0019
  830:  	{
  831:  		temp_line = board[line_row];
  0003 87           [1]     CLRA  
  0004 59           [1]     LSLD  
  0005 b745         [1]     TFR   D,X
  0007 ede20000     [4]     LDY   board,X
  832:  		board[line_row] = board[line_row - 1];
  000b ece20000     [4]     LDD   board:-2,X
  000f 6ce20000     [3]     STD   board,X
  833:  		board[line_row - 1] = temp_line;
  0013 6de20000     [3]     STY   board:-2,X
  0017 6380         [3]     DEC   0,SP
  0019 e680         [3]     LDAB  0,SP
  001b 26e6         [3/1]   BNE   *-24 ;abs = 0003
  834:  	}
  835:  
  836:  }
  001d 1b81         [2]     LEAS  1,SP
  001f 3d           [5]     RTS   
  837:  
  838:  /*
  839:  * This function checks if the tetris game is over
  840:  *	Receive:
  841:  *	 -void
  842:  *	Return:
  843:  *	 -bool (expressed as unsigned char because hc12 doesn't support bool): 1
  844:  *		1: game is over
  845:  *		0: game is not over
  846:  * The function checks 4 invisible line above playing rows if any block is present then the game is over
  847:  *
  848:  */
  849:  unsigned char is_game_over(void)
  850:  {
*** EVALUATION ***

Function: is_game_over
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 1b9c         [2]     LEAS  -4,SP
  851:  	int i, j;
  852:  	for (i = 0; i < HIDDEN_ROWS; i++)
  0002 186982       [3]     CLRW  2,SP
  853:  		for (j = 0; j < DISPLAY_WIDTH; j++)
  0005 186980       [3]     CLRW  0,SP
  854:  			if ((*board[i])[j].piece_type != NO_PIECE)
  0008 ee82         [3]     LDX   2,SP
  000a 1848         [2]     LSLX  
  000c ed80         [3]     LDY   0,SP
  000e 18ebe20000   [5]     ADDY  board,X
  0013 0f40e004     [4]     BRCLR 0,Y,#224,*+8 ;abs = 001b
  855:  				return 1;
  0017 c601         [1]     LDAB  #1
  0019 2015         [3]     BRA   *+23 ;abs = 0030
  001b 186280       [4]     INCW  0,SP
  001e ec80         [3]     LDD   0,SP
  0020 8c0008       [2]     CPD   #8
  0023 2de3         [3/1]   BLT   *-27 ;abs = 0008
  0025 186282       [4]     INCW  2,SP
  0028 ec82         [3]     LDD   2,SP
  002a 8c0004       [2]     CPD   #4
  002d 2dd6         [3/1]   BLT   *-40 ;abs = 0005
  856:  	return 0;
  002f c7           [1]     CLRB  
  857:  }
  0030 1b84         [2]     LEAS  4,SP
  0032 3d           [5]     RTS   
  858:  
  859:  
  860:  /*
  861:  * This function manages the pressed buttones which are used to play, this are present in
  862:  * "button_and_timers.c"
  863:  * According to the button pressed one of the following functions  is called
  864:  *	-move_piece_down : moves the active tetris piece down if possible
  865:  *	-move_piece_up : moves the active tetris piece up if possible
  866:  *	-move_piece_right : moves the active tetris piece right if possible
  867:  *	-move_piece_left : moves the active tetris piece left if possible.
  868:  *	-rotate_piece_clockwise : rotates the piece clockwise/right if possible.
  869:  *	-rotate_piece_counterclockwise : rotates the piece counterclockwise/left if possible.
  870:  */
  871:  void manage_button_down(signed char * x, signed char * y, piece_type_t * piece, rotation_t * rotation, EVENT_T * ev, unsigned char *drop_piece_f, game_states_t * current_state)
  872:  {
*** EVALUATION ***

Function: manage_button_down
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 3b           [2]     PSHD  
  873:  	switch (ev->data)//Possible buttons to press
  0001 ee86         [3]     LDX   6,SP
  0003 e601         [3]     LDAB  1,X
  0005 c106         [1]     CMPB  #6
  0007 182200b2     [4/3]   LBHI  *+182 ;abs = 00bd
  000b 87           [1]     CLRA  
  000c 160000       [4]     JSR   _CASE_CHECKED_BYTE
  000f 07           DC.B  7
  0010 ac           DC.B  172
  0011 07           DC.B  7
  0012 3b           DC.B  59
  0013 1a           DC.B  26
  0014 5a           DC.B  90
  0015 7b           DC.B  123
  0016 8b           DC.B  139
  0017 9d           DC.B  157
  874:  	{
  875:  	case JOYSTICK_UP:
  876:  		*drop_piece_f = 1; //Me parece que conviene como un estado pq es muy cabeza como esta pero nose...
  0018 ee84         [3]     LDX   4,SP
  001a c601         [1]     LDAB  #1
  001c 6b00         [2]     STAB  0,X
  877:  		set_timer_period_ms(TIMER_0, 50); //Lo mas rapido que se banca
  001e c7           [1]     CLRB  
  001f 37           [2]     PSHB  
  0020 c632         [1]     LDAB  #50
  0022 87           [1]     CLRA  
  0023 160000       [4]     JSR   set_timer_period_ms
  0026 1b81         [2]     LEAS  1,SP
  878:  		break;
  0028 060000       [3]     JMP   manage_button_down:0x00bd
  879:  
  880:  	case JOYSTICK_LEFT:
  881:  		if (move_piece_left(*x, *y, *piece, *rotation))
  002b ee8e         [3]     LDX   14,SP
  002d e600         [3]     LDAB  0,X
  002f 37           [2]     PSHB  
  0030 ed8d         [3]     LDY   13,SP
  0032 e640         [3]     LDAB  0,Y
  0034 37           [2]     PSHB  
  0035 ed8c         [3]     LDY   12,SP
  0037 ec40         [3]     LDD   0,Y
  0039 3b           [2]     PSHD  
  003a ed8c         [3]     LDY   12,SP
  003c ec40         [3]     LDD   0,Y
  003e 160000       [4]     JSR   move_piece_left
  0041 1b84         [2]     LEAS  4,SP
  0043 044177       [3]     TBEQ  B,*+122 ;abs = 00bd
  882:  			--(*x);
  0046 ee8e         [3]     LDX   14,SP
  0048 6300         [3]     DEC   0,X
  004a 2071         [3]     BRA   *+115 ;abs = 00bd
  883:  		break;
  884:  
  885:  	case JOYSTICK_DOWN:
  886:  		if (move_piece_down(*x, *y, *piece, *rotation))
  004c ee8e         [3]     LDX   14,SP
  004e e600         [3]     LDAB  0,X
  0050 37           [2]     PSHB  
  0051 ee8d         [3]     LDX   13,SP
  0053 e600         [3]     LDAB  0,X
  0055 37           [2]     PSHB  
  0056 ed8c         [3]     LDY   12,SP
  0058 ec40         [3]     LDD   0,Y
  005a 3b           [2]     PSHD  
  005b ed8c         [3]     LDY   12,SP
  005d ec40         [3]     LDD   0,Y
  005f 160000       [4]     JSR   move_piece_down
  0062 1b84         [2]     LEAS  4,SP
  0064 044156       [3]     TBEQ  B,*+89 ;abs = 00bd
  887:  			++(*y);
  0067 ee8c         [3]     LDX   12,SP
  0069 201d         [3]     BRA   *+31 ;abs = 0088
  888:  		break;
  889:  
  890:  	case JOYSTICK_RIGHT:
  891:  		if (move_piece_right(*x, *y, *piece, *rotation))
  006b ee8e         [3]     LDX   14,SP
  006d e600         [3]     LDAB  0,X
  006f 37           [2]     PSHB  
  0070 ed8d         [3]     LDY   13,SP
  0072 e640         [3]     LDAB  0,Y
  0074 37           [2]     PSHB  
  0075 ed8c         [3]     LDY   12,SP
  0077 ec40         [3]     LDD   0,Y
  0079 3b           [2]     PSHD  
  007a ed8c         [3]     LDY   12,SP
  007c ec40         [3]     LDD   0,Y
  007e 160000       [4]     JSR   move_piece_right
  0081 1b84         [2]     LEAS  4,SP
  0083 044137       [3]     TBEQ  B,*+58 ;abs = 00bd
  892:  			++(*x);
  0086 ee8e         [3]     LDX   14,SP
  0088 6200         [3]     INC   0,X
  008a 2031         [3]     BRA   *+51 ;abs = 00bd
  893:  		break;
  894:  
  895:  	case ROTATE_COUNT:
  896:  		if (rotate_piece_counterclockwise(x, y, piece, rotation))
  008c ec8e         [3]     LDD   14,SP
  008e 3b           [2]     PSHD  
  008f ec8e         [3]     LDD   14,SP
  0091 3b           [2]     PSHD  
  0092 ec8e         [3]     LDD   14,SP
  0094 3b           [2]     PSHD  
  0095 ec8e         [3]     LDD   14,SP
  0097 160000       [4]     JSR   rotate_piece_counterclockwise
  009a 200e         [3]     BRA   *+16 ;abs = 00aa
  897:  			;
  898:  		break;
  899:  
  900:  	case ROTATE_CLOCK:
  901:  		if (rotate_piece_clockwise(x, y, piece, rotation))
  009c ec8e         [3]     LDD   14,SP
  009e 3b           [2]     PSHD  
  009f ec8e         [3]     LDD   14,SP
  00a1 3b           [2]     PSHD  
  00a2 ec8e         [3]     LDD   14,SP
  00a4 3b           [2]     PSHD  
  00a5 ec8e         [3]     LDD   14,SP
  00a7 160000       [4]     JSR   rotate_piece_clockwise
  00aa 1b86         [2]     LEAS  6,SP
  00ac 200f         [3]     BRA   *+17 ;abs = 00bd
  902:  			;
  903:  		break;
  904:  
  905:  	case PAUSE: // Pause button
  906:  		if (*y >= 3)
  00ae ee8c         [3]     LDX   12,SP
  00b0 e600         [3]     LDAB  0,X
  00b2 c103         [1]     CMPB  #3
  00b4 2d07         [3/1]   BLT   *+9 ;abs = 00bd
  907:  			*current_state = GAME_PAUSED;
  00b6 ee80         [3]     LDX   0,SP
  00b8 c604         [1]     LDAB  #4
  00ba 87           [1]     CLRA  
  00bb 6c00         [2]     STD   0,X
  908:  		break;
  909:  
  910:  	default:
  911:  		break;
  912:  	}
  913:  }
  00bd 1b82         [2]     LEAS  2,SP
  00bf 3d           [5]     RTS   
  914:  
  915:  
  916:  unsigned char game_end_animation(signed char * y, piece_type_t last_piece_placed)
  917:  {
*** EVALUATION ***

Function: game_end_animation
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6cad         [2]     STD   3,-SP
  918:  	static unsigned char first_call = 1;
  919:  	unsigned char animation_finished = 0; //bool
  0002 6982         [2]     CLR   2,SP
  920:  	if (first_call)
  0004 f60000       [3]     LDAB  first_call
  0007 271c         [3/1]   BEQ   *+30 ;abs = 0025
  921:  	{
  922:  		*y = DISPLAY_HEIGHT + HIDDEN_ROWS - 1;
  0009 ee85         [3]     LDX   5,SP
  000b c623         [1]     LDAB  #35
  000d 6b00         [2]     STAB  0,X
  923:  		place_piece_line(*y, last_piece_placed);
  000f 37           [2]     PSHB  
  0010 ec81         [3]     LDD   1,SP
  0012 160000       [4]     JSR   place_piece_line
  924:  		set_timer_period_ms(TIMER_0, GAME_END_ANI_SPEED);
  0015 c7           [1]     CLRB  
  0016 6b80         [2]     STAB  0,SP
  0018 c64b         [1]     LDAB  #75
  001a 87           [1]     CLRA  
  001b 160000       [4]     JSR   set_timer_period_ms
  001e 1b81         [2]     LEAS  1,SP
  925:  		first_call = 0;
  0020 790000       [3]     CLR   first_call
  926:  	}
  0023 2026         [3]     BRA   *+40 ;abs = 004b
  927:  	else
  928:  	{
  929:  		if (*y > 0)
  0025 ee85         [3]     LDX   5,SP
  0027 e600         [3]     LDAB  0,X
  0029 2f19         [3/1]   BLE   *+27 ;abs = 0044
  930:  		{
  931:  			clear_line((*y) - 1);
  002b 53           [1]     DECB  
  002c 160000       [4]     JSR   clear_line
  932:  			move_line_up(*y);
  002f ee85         [3]     LDX   5,SP
  0031 e600         [3]     LDAB  0,X
  0033 160000       [4]     JSR   move_line_up
  933:  			set_row_redraw((*y) - 1);
  0036 ee85         [3]     LDX   5,SP
  0038 e600         [3]     LDAB  0,X
  003a 53           [1]     DECB  
  003b 160000       [4]     JSR   set_row_redraw
  934:  			--(*y);
  003e ee85         [3]     LDX   5,SP
  0040 6300         [3]     DEC   0,X
  935:  		}
  0042 2007         [3]     BRA   *+9 ;abs = 004b
  936:  		else
  937:  		{
  938:  			first_call = 1;
  0044 c601         [1]     LDAB  #1
  0046 7b0000       [3]     STAB  first_call
  939:  			animation_finished = 1; // true
  0049 6b82         [2]     STAB  2,SP
  940:  		}
  941:  	}
  942:  	return animation_finished;
  004b e682         [3]     LDAB  2,SP
  943:  }
  004d 1b83         [2]     LEAS  3,SP
  004f 3d           [5]     RTS   
  944:  
  945:  
  946:  
  947:  void clear_line(unsigned char y_cord)
  948:  {
*** EVALUATION ***

Function: clear_line
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6bae         [2]     STAB  2,-SP
  949:  	block_t empty;
  950:  	int x;
  951:  	empty.fall_piece = 0;
  952:  	empty.redraw = 1;
  0002 0c8102       [4]     BSET  1,SP,#2
  953:  	empty.piece_type = NO_PIECE;
  0005 0d81e1       [4]     BCLR  1,SP,#225
  954:  
  955:  	for (x = 0; x < DISPLAY_WIDTH; x++)
  0008 1887         [2]     CLRX  
  956:  		(*board[y_cord])[x] = empty;
  000a e680         [3]     LDAB  0,SP
  000c 87           [1]     CLRA  
  000d 59           [1]     LSLD  
  000e b746         [1]     TFR   D,Y
  0010 34           [2]     PSHX  
  0011 18abea0000   [5]     ADDX  board,Y
  0016 e683         [3]     LDAB  3,SP
  0018 6b00         [2]     STAB  0,X
  001a 30           [3]     PULX  
  001b 08           [1]     INX   
  001c 8e0008       [2]     CPX   #8
  001f 2de9         [3/1]   BLT   *-21 ;abs = 000a
  957:  }
  0021 1b82         [2]     LEAS  2,SP
  0023 3d           [5]     RTS   
  958:  
  959:  void move_line_up(unsigned char y_cord)
  960:  {
*** EVALUATION ***

Function: move_line_up
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  961:  	block_t(*temp_line)[DISPLAY_WIDTH];
  962:  	temp_line = board[y_cord];
  0000 87           [1]     CLRA  
  0001 59           [1]     LSLD  
  0002 b745         [1]     TFR   D,X
  0004 ede20000     [4]     LDY   board,X
  963:  	board[y_cord] = board[y_cord - 1];
  0008 ece20000     [4]     LDD   board:-2,X
  000c 6ce20000     [3]     STD   board,X
  964:  	board[y_cord - 1] = temp_line;
  0010 6de20000     [3]     STY   board:-2,X
  965:  }
  0014 3d           [5]     RTS   
  966:  
  967:  void place_piece_line(unsigned char y_cord, piece_type_t piece)
  968:  {
*** EVALUATION ***

Function: place_piece_line
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6cad         [2]     STD   3,-SP
  969:  	int x;
  970:  	block_t piece_block;
  971:  	piece_block.fall_piece = 0;
  0002 0d8201       [4]     BCLR  2,SP,#1
  972:  	piece_block.redraw = 1;
  0005 0c8202       [4]     BSET  2,SP,#2
  973:  	piece_block.piece_type = piece;
  0008 c620         [1]     LDAB  #32
  000a a681         [3]     LDAA  1,SP
  000c 12           [1]     MUL   
  000d e882         [3]     EORB  2,SP
  000f c4e0         [1]     ANDB  #224
  0011 e882         [3]     EORB  2,SP
  0013 6b82         [2]     STAB  2,SP
  974:  	for (x = 0; x < DISPLAY_WIDTH; x++)
  0015 1887         [2]     CLRX  
  975:  		(*board[y_cord])[x] = piece_block;
  0017 e685         [3]     LDAB  5,SP
  0019 87           [1]     CLRA  
  001a 59           [1]     LSLD  
  001b b746         [1]     TFR   D,Y
  001d 34           [2]     PSHX  
  001e 18abea0000   [5]     ADDX  board,Y
  0023 e684         [3]     LDAB  4,SP
  0025 6b00         [2]     STAB  0,X
  0027 30           [3]     PULX  
  0028 08           [1]     INX   
  0029 8e0008       [2]     CPX   #8
  002c 2de9         [3/1]   BLT   *-21 ;abs = 0017
  976:  }
  002e 1b83         [2]     LEAS  3,SP
  0030 3d           [5]     RTS   
  977:  
  978:  void set_row_redraw(unsigned char y_cord)
  979:  {
*** EVALUATION ***

Function: set_row_redraw
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 37           [2]     PSHB  
  980:  	int x;
  981:  	for (x = 0; x < DISPLAY_WIDTH; x++)
  0001 1887         [2]     CLRX  
  982:  		(*board[y_cord])[x].redraw = 1;
  0003 e680         [3]     LDAB  0,SP
  0005 87           [1]     CLRA  
  0006 59           [1]     LSLD  
  0007 b746         [1]     TFR   D,Y
  0009 34           [2]     PSHX  
  000a 18abea0000   [5]     ADDX  board,Y
  000f 0c0002       [4]     BSET  0,X,#2
  0012 30           [3]     PULX  
  0013 08           [1]     INX   
  0014 8e0008       [2]     CPX   #8
  0017 2dea         [3/1]   BLT   *-20 ;abs = 0003
  983:  }
  0019 1b81         [2]     LEAS  1,SP
  001b 3d           [5]     RTS   
  984:  
  985:  unsigned char clearing_row_animation(signed char y, unsigned char cleared_rows, unsigned long int * score)
  986:  {
*** EVALUATION ***

Function: clearing_row_animation
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6ca9         [2]     STD   7,-SP
  987:  	static unsigned char number_blinks_clear = NUM_BLINK_CLR_LINE, lines_cleared = 0;
  988:  
  989:  	unsigned char i, j, moving_mask, animation_finished = 0;
  0002 6986         [2]     CLR   6,SP
  990:  	block_t(*temp_line)[DISPLAY_WIDTH];
  991:  	block_t empty;
  992:  	empty.fall_piece = 0;
  993:  	empty.piece_type = NO_PIECE;
  0004 0c8502       [4]     BSET  5,SP,#2
  994:  	empty.redraw = 1;
  0007 0d85e1       [4]     BCLR  5,SP,#225
  995:  	if (number_blinks_clear-- > 0)
  000a f60000       [3]     LDAB  number_blinks_clear
  000d 37           [2]     PSHB  
  000e 53           [1]     DECB  
  000f 7b0000       [3]     STAB  number_blinks_clear
  0012 e6b0         [3]     LDAB  1,SP+
  0014 275c         [3/1]   BEQ   *+94 ;abs = 0072
  996:  	{
  997:  		for (j = 0, moving_mask = 0x01; j < PIECE_CONTAINER_SIZE; j++, moving_mask <<= 1)
  0016 6982         [2]     CLR   2,SP
  0018 c601         [1]     LDAB  #1
  001a 6b83         [2]     STAB  3,SP
  998:  			if (cleared_rows & moving_mask)
  001c e689         [3]     LDAB  9,SP
  001e e483         [3]     ANDB  3,SP
  0020 2743         [3/1]   BEQ   *+69 ;abs = 0065
  999:  			{
 1000:  				temp_line = board[y + j];
  0022 e68a         [3]     LDAB  10,SP
  0024 b714         [1]     SEX   B,D
  0026 b745         [1]     TFR   D,X
  0028 e682         [3]     LDAB  2,SP
  002a 87           [1]     CLRA  
  002b 1ae6         [2]     LEAX  D,X
  002d 1848         [2]     LSLX  
  002f b746         [1]     TFR   D,Y
  0031 ece20000     [4]     LDD   board,X
 1001:  				board[y + j] = board[j];
  0035 1858         [2]     LSLY  
  0037 3b           [2]     PSHD  
  0038 ecea0000     [4]     LDD   board,Y
  003c 6ce20000     [3]     STD   board,X
 1002:  				board[j] = temp_line;
  0040 3a           [3]     PULD  
  0041 6cea0000     [3]     STD   board,Y
 1003:  				for (i = 0; i <DISPLAY_WIDTH; i++)
  0045 c7           [1]     CLRB  
 1004:  					(*board[y + j])[i].redraw = 1;
  0046 a68a         [3]     LDAA  10,SP
  0048 37           [2]     PSHB  
  0049 b704         [1]     SEX   A,D
  004b b745         [1]     TFR   D,X
  004d e683         [3]     LDAB  3,SP
  004f 87           [1]     CLRA  
  0050 1ae6         [2]     LEAX  D,X
  0052 1848         [2]     LSLX  
  0054 e680         [3]     LDAB  0,SP
  0056 e3e20000     [4]     ADDD  board,X
  005a b745         [1]     TFR   D,X
  005c 0c0002       [4]     BSET  0,X,#2
  005f 33           [3]     PULB  
  0060 52           [1]     INCB  
  0061 c108         [1]     CMPB  #8
  0063 25e1         [3/1]   BCS   *-29 ;abs = 0046
  0065 6282         [3]     INC   2,SP
  0067 6883         [3]     LSL   3,SP
  0069 e682         [3]     LDAB  2,SP
  006b c104         [1]     CMPB  #4
  006d 25ad         [3/1]   BCS   *-81 ;abs = 001c
 1005:  				//(*board[j])[i].redraw = 1; // No se ve no tiene sentido redraw
 1006:  			}
 1007:  	}
  006f 060000       [3]     JMP   clearing_row_animation:0x00ff
 1008:  	else
 1009:  	{
 1010:  		for (j = 0, moving_mask = 0x01; j < PIECE_CONTAINER_SIZE; j++, moving_mask <<= 1)
  0072 6982         [2]     CLR   2,SP
  0074 c601         [1]     LDAB  #1
  0076 6b83         [2]     STAB  3,SP
 1011:  			if (cleared_rows & moving_mask)
  0078 e689         [3]     LDAB  9,SP
  007a e483         [3]     ANDB  3,SP
  007c 2733         [3/1]   BEQ   *+53 ;abs = 00b1
 1012:  				for (i = 0; i < DISPLAY_WIDTH; i++)
  007e 6984         [2]     CLR   4,SP
 1013:  				{
 1014:  					(*board[j])[i] = empty;
  0080 e682         [3]     LDAB  2,SP
  0082 87           [1]     CLRA  
  0083 b746         [1]     TFR   D,Y
  0085 59           [1]     LSLD  
  0086 b745         [1]     TFR   D,X
  0088 e684         [3]     LDAB  4,SP
  008a 87           [1]     CLRA  
  008b 3b           [2]     PSHD  
  008c e3e20000     [4]     ADDD  board,X
  0090 b745         [1]     TFR   D,X
  0092 e687         [3]     LDAB  7,SP
  0094 6b00         [2]     STAB  0,X
 1015:  					(*board[y + j])[i] = empty;
  0096 a68c         [3]     LDAA  12,SP
  0098 b704         [1]     SEX   A,D
  009a 19ee         [2]     LEAY  D,Y
  009c 1858         [2]     LSLY  
  009e 3a           [3]     PULD  
  009f e3ea0000     [4]     ADDD  board,Y
  00a3 b745         [1]     TFR   D,X
  00a5 e685         [3]     LDAB  5,SP
  00a7 6b00         [2]     STAB  0,X
  00a9 6284         [3]     INC   4,SP
  00ab e684         [3]     LDAB  4,SP
  00ad c108         [1]     CMPB  #8
  00af 25cf         [3/1]   BCS   *-47 ;abs = 0080
  00b1 6282         [3]     INC   2,SP
  00b3 6883         [3]     LSL   3,SP
  00b5 e682         [3]     LDAB  2,SP
  00b7 c104         [1]     CMPB  #4
  00b9 25bd         [3/1]   BCS   *-65 ;abs = 0078
 1016:  				}
 1017:  		//Soy tonto y no lo pude optimizar habria que verlo pero paja anda...
 1018:  		for (j = 0, moving_mask = 0x01; j < 4; j++, moving_mask <<= 1)
  00bb 6982         [2]     CLR   2,SP
  00bd c601         [1]     LDAB  #1
  00bf 6b83         [2]     STAB  3,SP
 1019:  			if (cleared_rows & moving_mask)
  00c1 e689         [3]     LDAB  9,SP
  00c3 e483         [3]     ANDB  3,SP
  00c5 270a         [3/1]   BEQ   *+12 ;abs = 00d1
 1020:  			{
 1021:  				move_line_to_top(y + j);
  00c7 e68a         [3]     LDAB  10,SP
  00c9 eb82         [3]     ADDB  2,SP
  00cb 160000       [4]     JSR   move_line_to_top
 1022:  				++lines_cleared;
  00ce 720000       [4]     INC   lines_cleared
  00d1 6282         [3]     INC   2,SP
  00d3 6883         [3]     LSL   3,SP
  00d5 e682         [3]     LDAB  2,SP
  00d7 c104         [1]     CMPB  #4
  00d9 25e6         [3/1]   BCS   *-24 ;abs = 00c1
 1023:  			}
 1024:  
 1025:  		*score += score_per_line_cleared[lines_cleared];
  00db f60000       [3]     LDAB  lines_cleared
  00de 87           [1]     CLRA  
  00df 59           [1]     LSLD  
  00e0 b745         [1]     TFR   D,X
  00e2 ece20000     [4]     LDD   score_per_line_cleared,X
  00e6 ee80         [3]     LDX   0,SP
  00e8 e302         [3]     ADDD  2,X
  00ea 6c02         [2]     STD   2,X
  00ec cc0000       [2]     LDD   #0
  00ef 18e300       [4]     ADED  0,X
  00f2 6c00         [2]     STD   0,X
 1026:  		animation_finished = 1;
  00f4 cc0301       [2]     LDD   #769
  00f7 6b86         [2]     STAB  6,SP
 1027:  		lines_cleared = 0, number_blinks_clear = NUM_BLINK_CLR_LINE;
  00f9 790000       [3]     CLR   lines_cleared
  00fc 7a0000       [3]     STAA  number_blinks_clear
 1028:  	}
 1029:  	return animation_finished;
  00ff e686         [3]     LDAB  6,SP
 1030:  
 1031:  }
  0101 1b87         [2]     LEAS  7,SP
  0103 3d           [5]     RTS   
 1032:  
 1033:  
 1034:  void draw_letter_t(piece_type_t piece, signed char y, signed char x)
 1035:  {
*** EVALUATION ***

Function: draw_letter_t
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6bae         [2]     STAB  2,-SP
 1036:  	block_t piece_block;
 1037:  	piece_block.fall_piece = 0;
  0002 0d8101       [4]     BCLR  1,SP,#1
 1038:  	piece_block.redraw = 1;
  0005 0c8102       [4]     BSET  1,SP,#2
 1039:  	piece_block.piece_type = (unsigned int)piece;
  0008 c620         [1]     LDAB  #32
  000a a686         [3]     LDAA  6,SP
  000c 12           [1]     MUL   
  000d e881         [3]     EORB  1,SP
  000f c4e0         [1]     ANDB  #224
  0011 e881         [3]     EORB  1,SP
  0013 6b81         [2]     STAB  1,SP
 1040:  	(*board[y])[x] = piece_block;
  0015 a680         [3]     LDAA  0,SP
  0017 b705         [1]     SEX   A,X
  0019 a684         [3]     LDAA  4,SP
  001b b706         [1]     SEX   A,Y
  001d 1858         [2]     LSLY  
  001f 34           [2]     PSHX  
  0020 18abea0000   [5]     ADDX  board,Y
  0025 6b00         [2]     STAB  0,X
 1041:  	(*board[y])[x + 1] = piece_block;
  0027 ee80         [3]     LDX   0,SP
  0029 35           [2]     PSHY  
  002a 1901         [2]     LEAY  1,X
  002c 30           [3]     PULX  
  002d 35           [2]     PSHY  
  002e 18ebe20000   [5]     ADDY  board,X
  0033 6b40         [2]     STAB  0,Y
 1042:  	(*board[y])[x + 2] = piece_block;
  0035 ed82         [3]     LDY   2,SP
  0037 1942         [2]     LEAY  2,Y
  0039 18ebe20000   [5]     ADDY  board,X
  003e 6b40         [2]     STAB  0,Y
 1043:  	(*board[y + 1])[x + 1] = piece_block;
  0040 ed80         [3]     LDY   0,SP
  0042 18ebe20000   [5]     ADDY  board:2,X
  0047 6b40         [2]     STAB  0,Y
 1044:  	(*board[y + 2])[x + 1] = piece_block;
  0049 ed80         [3]     LDY   0,SP
  004b 18ebe20000   [5]     ADDY  board:4,X
  0050 6b40         [2]     STAB  0,Y
 1045:  	(*board[y + 3])[x + 1] = piece_block;
  0052 ed80         [3]     LDY   0,SP
  0054 18ebe20000   [5]     ADDY  board:6,X
  0059 6b40         [2]     STAB  0,Y
 1046:  	(*board[y + 4])[x + 1] = piece_block;
  005b 31           [3]     PULY  
  005c 18ebe20000   [5]     ADDY  board:8,X
  0061 6b40         [2]     STAB  0,Y
  0063 1b84         [2]     LEAS  4,SP
 1047:  
 1048:  }
  0065 3d           [5]     RTS   
 1049:  
 1050:  void draw_letter_e(piece_type_t piece, signed char y, signed char x)
 1051:  {
*** EVALUATION ***

Function: draw_letter_e
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6bae         [2]     STAB  2,-SP
 1052:  	block_t piece_block;
 1053:  	piece_block.fall_piece = 0;
  0002 0d8101       [4]     BCLR  1,SP,#1
 1054:  	piece_block.redraw = 1;
  0005 0c8102       [4]     BSET  1,SP,#2
 1055:  	piece_block.piece_type = piece;
  0008 c620         [1]     LDAB  #32
  000a a686         [3]     LDAA  6,SP
  000c 12           [1]     MUL   
  000d e881         [3]     EORB  1,SP
  000f c4e0         [1]     ANDB  #224
  0011 e881         [3]     EORB  1,SP
  0013 6b81         [2]     STAB  1,SP
 1056:  
 1057:  	(*board[y])[x] = piece_block;
  0015 a680         [3]     LDAA  0,SP
  0017 b705         [1]     SEX   A,X
  0019 a684         [3]     LDAA  4,SP
  001b b706         [1]     SEX   A,Y
  001d 1858         [2]     LSLY  
  001f 34           [2]     PSHX  
  0020 18abea0000   [5]     ADDX  board,Y
  0025 6b00         [2]     STAB  0,X
 1058:  	(*board[y])[x + 1] = piece_block;
  0027 ee80         [3]     LDX   0,SP
  0029 35           [2]     PSHY  
  002a 1901         [2]     LEAY  1,X
  002c ee80         [3]     LDX   0,SP
  002e 35           [2]     PSHY  
  002f 18ebe20000   [5]     ADDY  board,X
  0034 6b40         [2]     STAB  0,Y
 1059:  	(*board[y])[x + 2] = piece_block;
  0036 ed84         [3]     LDY   4,SP
  0038 1a42         [2]     LEAX  2,Y
  003a ed82         [3]     LDY   2,SP
  003c 34           [2]     PSHX  
  003d 18abea0000   [5]     ADDX  board,Y
  0042 6b00         [2]     STAB  0,X
 1060:  
 1061:  	(*board[y + 1])[x] = piece_block;
  0044 ee86         [3]     LDX   6,SP
  0046 18abea0000   [5]     ADDX  board:2,Y
  004b 6b00         [2]     STAB  0,X
 1062:  	(*board[y + 2])[x] = piece_block;
  004d ee86         [3]     LDX   6,SP
  004f 18abea0000   [5]     ADDX  board:4,Y
  0054 6b00         [2]     STAB  0,X
 1063:  	(*board[y + 2])[x + 1] = piece_block;
  0056 ee82         [3]     LDX   2,SP
  0058 18abea0000   [5]     ADDX  board:4,Y
  005d 6b00         [2]     STAB  0,X
 1064:  	(*board[y + 2])[x + 2] = piece_block;
  005f ee80         [3]     LDX   0,SP
  0061 18abea0000   [5]     ADDX  board:4,Y
  0066 6b00         [2]     STAB  0,X
 1065:  
 1066:  	(*board[y + 3])[x] = piece_block;
  0068 ee86         [3]     LDX   6,SP
  006a 18abea0000   [5]     ADDX  board:6,Y
  006f 6b00         [2]     STAB  0,X
 1067:  	(*board[y + 4])[x] = piece_block;
  0071 ee86         [3]     LDX   6,SP
  0073 18abea0000   [5]     ADDX  board:8,Y
  0078 6b00         [2]     STAB  0,X
 1068:  	(*board[y + 4])[x + 1] = piece_block;
  007a ee82         [3]     LDX   2,SP
  007c 18abea0000   [5]     ADDX  board:8,Y
  0081 6b00         [2]     STAB  0,X
 1069:  	(*board[y + 4])[x + 2] = piece_block;
  0083 30           [3]     PULX  
  0084 18abea0000   [5]     ADDX  board:8,Y
  0089 6b00         [2]     STAB  0,X
  008b 1b88         [2]     LEAS  8,SP
 1070:  }
  008d 3d           [5]     RTS   
 1071:  
 1072:  void draw_letter_r(piece_type_t piece, signed char y, signed char x)
 1073:  {
*** EVALUATION ***

Function: draw_letter_r
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6bae         [2]     STAB  2,-SP
 1074:  	block_t piece_block;
 1075:  	piece_block.fall_piece = 0;
  0002 0d8101       [4]     BCLR  1,SP,#1
 1076:  	piece_block.redraw = 1;
  0005 0c8102       [4]     BSET  1,SP,#2
 1077:  	piece_block.piece_type = piece;
  0008 c620         [1]     LDAB  #32
  000a a686         [3]     LDAA  6,SP
  000c 12           [1]     MUL   
  000d e881         [3]     EORB  1,SP
  000f c4e0         [1]     ANDB  #224
  0011 e881         [3]     EORB  1,SP
  0013 6b81         [2]     STAB  1,SP
 1078:  	(*board[y])[x] = piece_block;
  0015 a680         [3]     LDAA  0,SP
  0017 b705         [1]     SEX   A,X
  0019 a684         [3]     LDAA  4,SP
  001b b706         [1]     SEX   A,Y
  001d 1858         [2]     LSLY  
  001f 34           [2]     PSHX  
  0020 18abea0000   [5]     ADDX  board,Y
  0025 6b00         [2]     STAB  0,X
 1079:  	(*board[y])[x + 1] = piece_block;
  0027 ee80         [3]     LDX   0,SP
  0029 35           [2]     PSHY  
  002a 1901         [2]     LEAY  1,X
  002c ee80         [3]     LDX   0,SP
  002e 35           [2]     PSHY  
  002f 18ebe20000   [5]     ADDY  board,X
  0034 6b40         [2]     STAB  0,Y
 1080:  	(*board[y])[x + 2] = piece_block;
  0036 ed84         [3]     LDY   4,SP
  0038 1a42         [2]     LEAX  2,Y
  003a ed82         [3]     LDY   2,SP
  003c 34           [2]     PSHX  
  003d 18abea0000   [5]     ADDX  board,Y
  0042 6b00         [2]     STAB  0,X
 1081:  
 1082:  	(*board[y + 1])[x + 2] = piece_block;
  0044 ee80         [3]     LDX   0,SP
  0046 18abea0000   [5]     ADDX  board:2,Y
  004b 6b00         [2]     STAB  0,X
 1083:  	(*board[y + 2])[x + 2] = piece_block;
  004d ee80         [3]     LDX   0,SP
  004f 18abea0000   [5]     ADDX  board:4,Y
  0054 6b00         [2]     STAB  0,X
 1084:  	(*board[y + 2])[x + 1] = piece_block;
  0056 ee82         [3]     LDX   2,SP
  0058 18abea0000   [5]     ADDX  board:4,Y
  005d 6b00         [2]     STAB  0,X
 1085:  	(*board[y + 3])[x + 1] = piece_block;
  005f ee82         [3]     LDX   2,SP
  0061 18abea0000   [5]     ADDX  board:6,Y
  0066 6b00         [2]     STAB  0,X
 1086:  	(*board[y + 4])[x + 2] = piece_block;
  0068 30           [3]     PULX  
  0069 18abea0000   [5]     ADDX  board:8,Y
  006e 6b00         [2]     STAB  0,X
 1087:  
 1088:  	(*board[y + 1])[x] = piece_block;
  0070 ee84         [3]     LDX   4,SP
  0072 18abea0000   [5]     ADDX  board:2,Y
  0077 6b00         [2]     STAB  0,X
 1089:  	(*board[y + 2])[x] = piece_block;
  0079 ee84         [3]     LDX   4,SP
  007b 18abea0000   [5]     ADDX  board:4,Y
  0080 6b00         [2]     STAB  0,X
 1090:  	(*board[y + 3])[x] = piece_block;
  0082 ee84         [3]     LDX   4,SP
  0084 18abea0000   [5]     ADDX  board:6,Y
  0089 6b00         [2]     STAB  0,X
 1091:  	(*board[y + 4])[x] = piece_block;
  008b ee84         [3]     LDX   4,SP
  008d 18abea0000   [5]     ADDX  board:8,Y
  0092 6b00         [2]     STAB  0,X
  0094 1b88         [2]     LEAS  8,SP
 1092:  
 1093:  
 1094:  }
  0096 3d           [5]     RTS   
 1095:  
 1096:  void draw_letter_i(piece_type_t piece, signed char y, signed char x)
 1097:  {
*** EVALUATION ***

Function: draw_letter_i
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6bae         [2]     STAB  2,-SP
 1098:  	block_t piece_block;
 1099:  	piece_block.fall_piece = 0;
  0002 0d8101       [4]     BCLR  1,SP,#1
 1100:  	piece_block.redraw = 1;
  0005 0c8102       [4]     BSET  1,SP,#2
 1101:  	piece_block.piece_type = piece;
  0008 c620         [1]     LDAB  #32
  000a a686         [3]     LDAA  6,SP
  000c 12           [1]     MUL   
  000d e881         [3]     EORB  1,SP
  000f c4e0         [1]     ANDB  #224
  0011 e881         [3]     EORB  1,SP
  0013 6b81         [2]     STAB  1,SP
 1102:  	(*board[y])[x] = piece_block;
  0015 a680         [3]     LDAA  0,SP
  0017 b705         [1]     SEX   A,X
  0019 a684         [3]     LDAA  4,SP
  001b b706         [1]     SEX   A,Y
  001d 1858         [2]     LSLY  
  001f 34           [2]     PSHX  
  0020 18abea0000   [5]     ADDX  board,Y
  0025 6b00         [2]     STAB  0,X
 1103:  	(*board[y])[x + 1] = piece_block;
  0027 ee80         [3]     LDX   0,SP
  0029 35           [2]     PSHY  
  002a 1901         [2]     LEAY  1,X
  002c ee80         [3]     LDX   0,SP
  002e 35           [2]     PSHY  
  002f 18ebe20000   [5]     ADDY  board,X
  0034 6b40         [2]     STAB  0,Y
 1104:  	(*board[y])[x + 2] = piece_block;
  0036 ed84         [3]     LDY   4,SP
  0038 1a42         [2]     LEAX  2,Y
  003a ed82         [3]     LDY   2,SP
  003c 34           [2]     PSHX  
  003d 18abea0000   [5]     ADDX  board,Y
  0042 6b00         [2]     STAB  0,X
 1105:  
 1106:  	(*board[y + 1])[x + 1] = piece_block;
  0044 ee82         [3]     LDX   2,SP
  0046 18abea0000   [5]     ADDX  board:2,Y
  004b 6b00         [2]     STAB  0,X
 1107:  	(*board[y + 2])[x + 1] = piece_block;
  004d ee82         [3]     LDX   2,SP
  004f 18abea0000   [5]     ADDX  board:4,Y
  0054 6b00         [2]     STAB  0,X
 1108:  	(*board[y + 3])[x + 1] = piece_block;
  0056 ee82         [3]     LDX   2,SP
  0058 18abea0000   [5]     ADDX  board:6,Y
  005d 6b00         [2]     STAB  0,X
 1109:  
 1110:  	(*board[y + 4])[x] = piece_block;
  005f ee86         [3]     LDX   6,SP
  0061 18abea0000   [5]     ADDX  board:8,Y
  0066 6b00         [2]     STAB  0,X
 1111:  	(*board[y + 4])[x + 1] = piece_block;
  0068 ee82         [3]     LDX   2,SP
  006a 18abea0000   [5]     ADDX  board:8,Y
  006f 6b00         [2]     STAB  0,X
 1112:  	(*board[y + 4])[x + 2] = piece_block;
  0071 30           [3]     PULX  
  0072 18abea0000   [5]     ADDX  board:8,Y
  0077 6b00         [2]     STAB  0,X
  0079 1b88         [2]     LEAS  8,SP
 1113:  }
  007b 3d           [5]     RTS   
 1114:  
 1115:  void draw_letter_s(piece_type_t piece, signed char y, signed char x)
 1116:  {
*** EVALUATION ***

Function: draw_letter_s
Source  : C:\Users\R2D2\Desktop\TETRIS\Sources\main.c
Options : -CPUHCS12X -D__NO_FLOAT__ -Env"GENPATH=C:\Users\R2D2\Desktop\TETRIS;C:\Users\R2D2\Desktop\TETRIS\bin;C:\Users\R2D2\Desktop\TETRIS\prm;C:\Users\R2D2\Desktop\TETRIS\cmd;C:\Users\R2D2\Desktop\TETRIS\Sources;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\lib;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\src;C:\Users\R2D2\Desktop\TETRIS\Sources\DP256Reg;C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -Env"LIBPATH=C:\Program Files (x86)\Freescale\CWS12v5.1\lib\HC12c\include" -EnvOBJPATH=C:\Users\R2D2\Desktop\TETRIS\bin -EnvTEXTPATH=C:\Users\R2D2\Desktop\TETRIS\bin -Lasm=%n.lst -Lasmc= -Ms -Ot -ObjN=C:\Users\R2D2\Desktop\TETRIS\TETRIS_Data\RAM\ObjectCode\main.c.o -WmsgSd1106

  0000 6bae         [2]     STAB  2,-SP
 1117:  	block_t piece_block;
 1118:  	piece_block.fall_piece = 0;
  0002 0d8101       [4]     BCLR  1,SP,#1
 1119:  	piece_block.redraw = 1;
  0005 0c8102       [4]     BSET  1,SP,#2
 1120:  	piece_block.piece_type = piece;
  0008 c620         [1]     LDAB  #32
  000a a686         [3]     LDAA  6,SP
  000c 12           [1]     MUL   
  000d e881         [3]     EORB  1,SP
  000f c4e0         [1]     ANDB  #224
  0011 e881         [3]     EORB  1,SP
  0013 6b81         [2]     STAB  1,SP
 1121:  	(*board[y])[x] = piece_block;
  0015 a680         [3]     LDAA  0,SP
  0017 b705         [1]     SEX   A,X
  0019 a684         [3]     LDAA  4,SP
  001b b706         [1]     SEX   A,Y
  001d 1858         [2]     LSLY  
  001f 34           [2]     PSHX  
  0020 18abea0000   [5]     ADDX  board,Y
  0025 6b00         [2]     STAB  0,X
 1122:  	(*board[y])[x + 1] = piece_block;
  0027 ee80         [3]     LDX   0,SP
  0029 35           [2]     PSHY  
  002a 1901         [2]     LEAY  1,X
  002c ee80         [3]     LDX   0,SP
  002e 35           [2]     PSHY  
  002f 18ebe20000   [5]     ADDY  board,X
  0034 6b40         [2]     STAB  0,Y
 1123:  	(*board[y])[x + 2] = piece_block;
  0036 ed84         [3]     LDY   4,SP
  0038 1a42         [2]     LEAX  2,Y
  003a ed82         [3]     LDY   2,SP
  003c 34           [2]     PSHX  
  003d 18abea0000   [5]     ADDX  board,Y
  0042 6b00         [2]     STAB  0,X
 1124:  
 1125:  	(*board[y + 1])[x] = piece_block;
  0044 ee86         [3]     LDX   6,SP
  0046 18abea0000   [5]     ADDX  board:2,Y
  004b 6b00         [2]     STAB  0,X
 1126:  	(*board[y + 2])[x] = piece_block;
  004d ee86         [3]     LDX   6,SP
  004f 18abea0000   [5]     ADDX  board:4,Y
  0054 6b00         [2]     STAB  0,X
 1127:  	(*board[y + 2])[x + 1] = piece_block;
  0056 ee82         [3]     LDX   2,SP
  0058 18abea0000   [5]     ADDX  board:4,Y
  005d 6b00         [2]     STAB  0,X
 1128:  	(*board[y + 2])[x + 2] = piece_block;
  005f ee80         [3]     LDX   0,SP
  0061 18abea0000   [5]     ADDX  board:4,Y
  0066 6b00         [2]     STAB  0,X
 1129:  
 1130:  	(*board[y + 3])[x + 2] = piece_block;
  0068 ee80         [3]     LDX   0,SP
  006a 18abea0000   [5]     ADDX  board:6,Y
  006f 6b00         [2]     STAB  0,X
 1131:  	(*board[y + 4])[x] = piece_block;
  0071 ee86         [3]     LDX   6,SP
  0073 18abea0000   [5]     ADDX  board:8,Y
  0078 6b00         [2]     STAB  0,X
 1132:  	(*board[y + 4])[x + 1] = piece_block;
  007a ee82         [3]     LDX   2,SP
  007c 18abea0000   [5]     ADDX  board:8,Y
  0081 6b00         [2]     STAB  0,X
 1133:  	(*board[y + 4])[x + 2] = piece_block;
  0083 30           [3]     PULX  
  0084 18abea0000   [5]     ADDX  board:8,Y
  0089 6b00         [2]     STAB  0,X
  008b 1b88         [2]     LEAS  8,SP
 1134:  }
  008d 3d           [5]     RTS   
